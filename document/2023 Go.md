2023 重新开始学习 Golang，顺便使用笔记记录下来学习的过程。
## Go 入门
Go语言基础入门和并发编程
### Go 基础知识入门
#### 1.编程环境配置
**下载安装**
以下为 MacOS 系统下的配置，不同系统大同小异，思路一致
- go 下载安装：https://golang.google.cn/
- ide 下载安装：https://www.jetbrains.com/go/
都推荐直接去官网下载安装，至于网络问题和 goland 授权码自行解决（前者通过梯子出去下载，后者可以通过官网申请个人开发人的秘钥，有效期一年，到期支持续费，具体自行Google）
- 环境配置：需要修改~/.bash_profile文件的内容，具体可以参考下面这篇文章
`https://juejin.cn/post/6950558763539496991`
最后可以通过 go version验证是否安装成功
![](https://s2.loli.net/2023/04/10/SRFLIcZXMb1QsUk.png)
****
#### 2.语言结构
**Hello world**
```
package main

import "fmt"

func main() {
	// 这是我的 go 演示程序
	fmt.Println("Hello world!")
}
```
1. 第一行代码 _package main_ 定义了包名。你必须在源文件中非注释的第一行指明这个文件属于哪个包，如：package main。package main表示一个可独立执行的程序，每个 Go 应用程序都包含一个名为 main 的包
2. 下一行 _import "fmt"_ 告诉 Go 编译器这个程序需要使用 fmt 包（的函数，或其他元素），fmt 包实现了格式化 IO（输入/输出）的函数
3. 下一行 _func main()_ 是程序开始执行的函数。main 函数是每一个可执行程序所必须包含的，一般来说都是在启动后第一个执行的函数（如果有 init() 函数则会先执行该函数）
4. 下一行 /*...*/ 是注释，在程序执行时将被忽略。单行注释是最常见的注释形式，你可以在任何地方使用以 // 开头的单行注释。多行注释也叫块注释，均已以 /* 开头，并以 */ 结尾，且不可以嵌套使用，多行注释一般用于包的文档描述或注释成块的代码片段
5. 下一行 /*...*/ 是注释，在程序执行时将被忽略。单行注释是最常见的注释形式，你可以在任何地方使用以 // 开头的单行注释。多行注释也叫块注释，均已以 /* 开头，并以 */ 结尾，且不可以嵌套使用，多行注释一般用于包的文档描述或注释成块的代码片段
6. 当标识符（包括常量、变量、类型、函数名、结构字段等等）以一个大写字母开头，如：Group1，那么使用这种形式的标识符的对象就可以被外部包的代码所使用（客户端程序需要先导入这个包），这被称为导出（像面向对象语言中的 public）；标识符如果以小写字母开头，则对包外是不可见的，但是他们在整个包的内部是可见并且可用的（像面向对象语言中的 protected ）

**执行应用程序**
假设刚才的代码在 main.go文件中
1. 方式一：go run main.go
2. 方式二：先`$ go build`生成二进制文件，然后运行对应的二进制文件`$ ./main`
****
#### 3.基础语法
**Go 标记**
一个 go 的应用程序可以由多个标记组成，可以使关键之、标识符、常量、字符串、符号，如下的 Go 语句由 6 个标记组成：
>	fmt.Println("Hello world!")
>	6 个标记分别是：
>	1. fmt
>	2. .
>	3. Println
>	4. (
>	5. "Hello World!"
>	6. )

**行分隔符**
一行就代表一个语句结束，无需类 Java 强制性使用分号结尾
**注释**
- 单行注释：`// 这是单行注释`
- 多行注释：
  ```
  /*
  演示
  这是多行注释
  */
  ```

**标识符**
标识符用来命名变量、类型等程序实体。一个标识符实际上就是一个或是多个字母(A~Z和a~z)数字(0~9)、下划线_组成的序列，但是第一个字符必须是字母或下划线而不能是数字
- 有效标识符
  >	mahesh   kumar   abc   move_name   a_123 myname50   _temp   j   a23b9   retVal
- 无效标识符
  >	1. 1ab（以数字开头）
  >	2. case（Go 语言的关键字）
  >	3. a+b（运算符是不允许的）

**字符串连接**
可以通过`+`来连接多个字符串
```
s1 := "Hello"
s2 := "World"
fmt.Println(s1 + s2)
```

**关键字**
Go 代码中会使用到的 25 个关键字或保留字：
![](https://s2.loli.net/2023/04/10/znyhsAq7352NcYH.png)
除了以上介绍的这些关键字，Go 语言还有 36 个预定义标识符：
![](https://s2.loli.net/2023/04/10/cKBlMNCF2vdDb6L.png)
**空格**
在 Go 语言中，空格通常用于分隔标识符、关键字、运算符和表达式，以提高代码的可读性
**格式化字符串**
Go 语言中使用 fmt.Sprintf 或 fmt.Printf 格式化字符串并赋值给新串
- Sprintf：根据格式化参数生成格式化的字符串并返回该字符串
- Printf：根据格式化参数生成格式化的字符串并写入标准输出

****
#### 4.数据类型
- 布尔型：布尔型的值只可以是常量 true 或者 false。一个简单的例子：var b bool = true。
- 数字类型：整型 int 和浮点型 float32、float64，Go 语言支持整型和浮点型数字，并且支持复数，其中位的运算采用补码
  **数字类型**
  Go 也有基于架构的类型，例如：int、uint 和 uintptr
	- uint8：无符号 8 位整型 (0 到 255)
	- uint16：无符号 16 位整型 (0 到 65535)
	- uint32：无符号 32 位整型 (0 到 4294967295)
	- uint64：无符号 64 位整型 (0 到 18446744073709551615)
	- int8：有符号 8 位整型 (-128 到 127)
	- int16：有符号 16 位整型 (-32768 到 32767)
	- int32：有符号 32 位整型 (-2147483648 到 2147483647)
	- int64：有符号 64 位整型 (-9223372036854775808 到 9223372036854775807)
  
  **浮点型**
	  - float32：IEEE-754 32位浮点型数
	  - float64：IEEE-754 64位浮点型数
	  - complex64：32 位实数和虚数
	  - complex128：64 位实数和虚数
  
  **其他数字类型**
	  - byte：类似 unit8
	  - rune：类似 int32
	  - uint：32 或 64 位
	  - int：与 uint 一样大小
	  - uintptr：无符号整型，用户存放一个指针

- 字符串类型：字符串就是一串固定长度的字符连接起来的字符序列
- 派生类型
	- 指针
	- 数组
	- 结构体（struct）
	- 通道（channel）
	- 函数
	- 切片（slice）
	- 接口（interface）
	- Map
****
#### 5.变量
Go 语言变量名由字母、数字、下划线组成，其中首个字符不能为数字。
声明变量的一般形式是使用 var 关键字：
`var identifier type`
可以单次声明多个变量：
`var identifier1, identfier2 type`

**变量声明**
第一种：指定变量类型，如果没有初始化，则变量默认为对应类型的零值
`var userName string   userName = "万里"`

不同数据类型对应的零值：
- 数值类型（包含 complex64/128）：0
- 布尔型：false
- 字符串：""（空串）
- 以下几种均为 nil
	- var a *int
	- var a []int
	- var a map[string] int
	- var a chan int
	- var a func(string) int
	- var a error // error 是接口

第二种：类型推导，根据值自行判定变量类型
`var userName = "万里"`  // 自动判断 userName 为 string 类型

第三种：如果变量使用 var 声明过了，再使用`:=`声明变量，就会产生编译错误，直接使用下面语句即可：
`userName := "万里"`
以上语句相当于：
```
var userName string
userName = "万里"
```

**多变量声明**
```
// 相同类型多个变量，非全局变量
var v1, v2, v3 type
v1, v2, v3 = 1, 2, 3

// 无需显示声明类型，自动推断
var v1, v2, v3 = 1, 2, 3

// 全局变量声明
var (
	v1 type
	v2 type
)
```

**值类型和引用类型**
所有像 int、float、bool和 string 这些基本类型都属于值类型，使用这些类型的变量直接指向在内存中的值
当使用等号将一个变量的值赋值给另一个变量时，如：i = j，实际上是在内存中将 j 的值进行了拷贝。我们可以通过&j 来获取变量 j 的内存地址
值类型变量的值存储在堆中。内存地址会根据机器的不同而有所不同，甚至相同的程序在不同的机器上执行后也会有不同的内存地址，因为每台机器可能有不同的存储器布局，并且位置分配也可能不同
一个引用类型的变量 r1 存储的是 r1 的值所对应的内存地址或内存地址中第一个字所在的位置
这个内存地址称之为指针，这个指针实际上也被存在另外的某一个值中
同一个引用类型的指针指向的多个字可以使在连续的内存地址中（内存布局是连续的），这也是计算效率最高的一种存储方式；也可以将这些字分散存放在内存中，每个字都指示了下一个字所在的内存地址
当使用赋值语句 r2 = r1 时，只有引用（地址）被复制。
如果 r1 的值被改变了，那么这个值的所有引用都会指向被修改后的内容，在这个例子中，r2 也会受到影响

**简短形式 使用 := 赋值操作符**
我们可以通过使用 := 赋值操作符来定义对应的变量，`userNmae := "万里"`，同样的，系统也会自动根据变量的值做类型推导

**注意事项**
a := 20
在同一个代码块中，不能对一个变量重复使用`:=`定义，如`a := 20`会产生编译错误：no new variables on left side of :=，但是我们可以对已定义的变量进行`=`来赋值，如`a = 20`
如果定义了一个局部变量 a，但是没有在代码中使用到它，会产生编译错误，在 Golang 中，变量的定义必须要使用到，除非使用`_`接收，例如`_, err := os.xxx`，但是该行为对于全局变量来说是被允许的
****
#### 6.常量
**定义**
我们可以使用如下语句来定义常量：
```
// 其中 [type] 也是跟变量相同，可以省略，编译器可以通过变量的值来推断其类型
const identifier [type] = value

const USER_TEACHER int = 0 // 指定 type，称为显示类型定义
const USER_STUDENT int = 10 // 未指定 type，称为隐式类型定义

// 同时定义多个常量，定义常量用户类型的枚举值
const USER_TEACHER, USER_STUDENT = 0, 10
```

**iota**
特殊常量，可以认为是一个可以被编译器修改的常量
iota 在 const关键字出现时将被重置为 0(const 内部的第一行之前)，const 中每新增一行常量声明将使 iota 计数一次(iota 可理解为 const 语句块中的行索引)
```
// iota 定义枚举
const (
	a = iota
	b
	c
)
// a、b、c 的值分别为 0，1，2
```
****
#### 7.运算符
运算符用于在程序运行时执行数学或逻辑运算
Go 语言内置的运算符有：
-   算术运算符
	- + ：相加
	- - ：相减
	- * ：相乘
	- / ：相除
	- % ：求余
	- ++ ：自增
	- -- ：自减
-   关系运算符
	- == ：检查是否相等，真为 true，假为 false
	- != ：检查是否不相等
	- > ：检查左边值是否大于右边
	- <：检查左边值是否小于右边
	- >= ：检查左边值是否大于等于右边
	- <= ：检查左边值是否小于等于右边
-   逻辑运算符
	- && ： 逻辑and运算符，两边真则为 true，反之为 false
	- || ：逻辑 or 运算符，两边有一个真则为 true，反之 false
	- ! ：逻辑 not 运算符，如果条件真，则为 false，反之为 true
-   位运算符
-   赋值运算符
	- = ：讲一个表达式的值赋值给一个左值。例：a = c+b 将 a+b 表达式的结果赋值给 a
	- += ：相加后再赋值。例：a+=c 等于 a=a+c
	- -= ：相减后再赋值。例：a-=c 等于 a=a-c
	- *= 、/=、%=同上
	- <<= ：左移后赋值。例：a>>=2等于 a=a<<2
	- >>= ：右移后赋值
	- &= ：按位与后赋值
	- ^= ：按位移后赋值
	- |= ：按位或后赋值
-   其他运算符
	- & ：返回变量存储地址。例：&a：将给出变量的实际地址
	- * ：指针变量。例：* a：是一个指针变量

**运算符优先级**
⭐️⭐️⭐️⭐️⭐️：* 、/ 、% 、<< 、>> 、& 、&^
⭐️⭐️⭐️⭐️：+ 、- 、| 、^
⭐️⭐️⭐️：== 、!= 、< 、<= 、> 、>=
⭐️⭐️：&&
⭐️：||
****
#### 8.条件语句
条件语句需要开发者通过指定一个或多个条件，并通过测试条件是否为 true 来决定是否执行指定语句，并在条件为 false 的情况在执行另外的语句。
下图展示了程序语言中条件语句的结构：
![](https://s2.loli.net/2023/04/15/5SdDlBzbhcJ2P9v.png)
Go 提供了以下几种条件判断语句：
- if：if 语句由一个布尔表达式后紧跟一个或多个语句组成
- if...else：if 语句后可以使用可选的 else 语句，else 语句中的表达式在布尔表达式为 false 时执行
- if 嵌套语句：你可以在 if 或 else if 语句中前入一个或多个 if 或 else if 语句
- switch：switch 语句用于基于不同条件执行不同动作
- select：select 语句类似于 switch 语句，但是 select 会随机执行一个可运行的 case，如果没有 case 可运行，他讲阻塞，直到有 case 可运行
****
#### 9.循环语句
在不少实际问题中有许多具有规律性的重复操作，因此在程序中就需要重复执行某些语句。
以下为大多编程语言循环程序的流程图：
![](https://s2.loli.net/2023/04/15/LpfGt6HmwPAOa3I.png)
Go 语言提供了以下几种类型循环处理语句：
- for 循环：重复执行语句块
- 循环嵌套：在 for 循环中签到一个或多个 for 循环
**循环控制语句**
循环控制语句可以控制循环体内语句的执行过程
Go 支持以下几种循环控制语句：
- break：经常用于中断当前 for 循环或跳出 switch 语句
- continue：跳过当前循环的剩余语句，然后继续进行下一轮循环
- goto：将控制转移到被标记的语句
**无限循环**
如果循环中的条件语句永远为真则会进行无限循环，我们可以通过 for 循环语句中只设置一个条件表达式来执行无限循环：
```
package main

import "fmt"

func main() {
	for true {
	fmt.Println("这是无线循环的 demo")}
}
```
****
#### 10.函数
函数是基本的代码块，用于执行一个任务。
Go 语言最少有个 main() 函数。
你可以通过函数来划分不同功能，逻辑上每个函数执行的是指定的任务。
函数声明告诉了编译器函数的名称、返回类型和参数
**函数定义**
```
func function_name( [parameter list] ) [return_types] {
   函数体
}
```
**函数定义解析**
- func：函数由 func 开始声明
- function_name：函数名称
- parameter list：参数列表（也叫形参），参数就像是一个占位符，当函数被调用时，你可以将值传递给参数，这个值我们称为实参。参数列表指定的是参数类型、顺序、个数。参数是可选的，也就是说函数也可以没有参数
- return_types：返回类型，函数返回一列值。return_types 是该列值的数据类型
- 函数体：函数定义的代码集合
**函数调用**
当创建函数时，你定义了函数需要做什么，通过调用该函数来执行指定任务。
调用函数，向函数传递参数，并返回值
**多个返回值**
一个函数可以返回多个值：
```
package main 

import "fmt"

func swap(a, b) string, string {
	return b ,a
}

func main() {
	a, b = "万里", "你好"
	fmt.Println(swap(a, b))
}

以上输出：你好万里
```
**函数参数**
函数如果使用参数，该变量可称为函数的形参。
形参就像定义在函数体内的局部变量。
调用函数，可以通过两种方式来传递参数：
- 值传递：值传递是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响实际参数
- 引用传递：引用传递是指在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改会影响到实际参数
默认情况下，Go 试用的是值传递，即在调用的过程中不会影响到实际参数
**函数用法**
- 函数作为另外一个函数的实参：函数定义后可作为另外一个函数的实参传入
- 闭包：闭包是匿名函数，可在动态编程中使用
- 方法：方法就是一个包含了接受者的函数
****
#### 11.变量作用域

****
#### 12.数组

****
#### 13.指针

****
#### 14.结构体

****
#### 15.切片（slice）

****
#### 16.范围（range）

****
#### 17.Map（集合）

****
#### 18.递归函数

****
#### 19.类型转换

****
#### 20.接口

****
#### 21.错误处理

****
#### 22.并发

****
