### 自我介绍
>问：请简单做一下自我介绍吧
  主要介绍一下自己的个人背景+工作背景+内容+亮点（如有）
>答：面试官你好，我叫张三，2016年毕业于某学校的某专业（拿不出就不需要提，比如非本科或者非计算机相关的专业），从毕业至今从事软件测试已有6年多的工作经验，比较熟悉B/S和C/S 架构的应用测试。先后在a公司和b公司（时间段+行业）任职，在公司作为业务线的测试负责人，主要负责产品线的测试工作以及相关评审、排期、资源分配、项目推进、测试流程优化等内容来把控项目风险以及产品质量保障。除了完成产品的功能测试以外，我还会通过其他的方式来保障产品质量和提升测试效率，比如自动化测试、兼容性测试、性能测试、稳定性测试、用户体验测试等方面的专项测试。
****
### 测试理论相关

**测试用例**
>问：测试用例设计的方法有哪些，你一般工作中会用到哪些测试用例的设计方法？
   用例设计其实是分为功能测试用例和单元测试用例设计的（黑盒和白盒），如果问题中没有确定是针对哪一个场景的，建议都回答上
>答：测试用例设计分为功能测试用例和单元测试用例设计，功能测试用例设计常用的方法有等价类、边界值分析、因果图、正交试验设计、功能图分析、错误推断、需求文档转换、随机测试、对象属性分析。单元测试的用例设计有语句覆盖、判定覆盖、条件覆盖、判定条件覆盖、条件组合覆盖、路径覆盖。
>功能中主要以黑盒测试为主，所以用到的就是功能测试用例设计的方法，一般常用的都是等价类分析（有效等价类、无效等价类）、边界值分析、错误推断、需求文档转换、对象属性分析、场景法等

>场景：登录页面的测试用例设计？

针对该问题首先需要考虑的是功能层面的问题，其次还要考虑安全、兼容性、性能、用户体验等方面的测试用例

>功能层面：
>1.输入已注册的用户名和正确的密码，验证是否登录成功
>2.输入已注册的用户名和错误的密码，验证是否登录失败
>3.输入未注册的用户名和任意的密码，验证是否登录失败
>4.不输入用户名和密码，验证是否登录失败
>5.用户名或密码不输入，验证是否登录失败
>6.如果有验证码，在用户名和密码都正确的情况下，输入正确的验证码，验证是否登录成功
>7.如果有验证码，在用户名和密码都正确的情况下，输入错误的验证码，验证是否登录失败
>8.用户名密码针对大小写是否敏感
>9.密码是否加密展示
>10.系统创建的用户首次登录是否提示修改密码
>11.忘记密码功能是否可用
>12.前端是否根据需求限制用户名和密码的长度
>13.如果需要验证码，点击验证码是否可以更换验证码，更换后的验证码是否可以正常使用登录
>14.刷新页面是否会刷新验证码
>15.如果是具有实效性的短信验证码，验证在时效内和时效外验证码的有效性
>16.会话超时操作是否回返回到登录页面
>17.不同角色的账户登录是否返回不同的角色菜单
>18.访问页面时默认的焦点是否在用户名输入框
>19.针对用户名、密码、验证码输入框是否可以正常使用快捷键tab、enter
>20.鼠标光标的状态展示，只有在固定的位置才显示可点击或编辑状态
>21.如果账号设置了单点登录，验证同一个账号在多个浏览器或电脑登录是否会将原有的会话置为过期
>安全层面：
>1.如果是短信验证码， 当天是否有接收限制（防刷）
>2.用户密码及个人信息是否加密存储
>3.前后端交互（请求接口）针对敏感信息是否加密（密码、手机号码等）
>4.后端是否会返回用户数据的敏感信息（创建时间、用户id等等）
>5.未登录的情况下，访问登录后的路由是否会重定向到登录页
>6.密码输入框是否不支持复制粘贴
>7.密码输入框的密码是否无法在开发者工具下查看
>8.连续多次的密码错误是否会有保护机制（防止暴力破解）
>9.登录接口返回的数据是否对用户信息进行加密显示
>10.登录ua获取，确保是用户本人登录
>性能层面：
>1.单用户登录的响应时长是否小于2秒
>2.单用户登录时，后台请求数量是否过多
>3.高并发场景下用户登录的响应时间是否小于5秒
>4.高并发的场景下，服务监控的各项指标是否正常（响应时长、数据库、服务器资源）
>5.防止同一用户恶意并发
>兼容层面：
>1.不同类型的浏览器下，验证登录页面的显示以及功能的正确性
>2.同一浏览器的不同版本（高低）下，验证登录页面的显示以及功能的正确性
>3.不同移动终端设备的不同浏览器下，验证登录页面的显示以及功能的正确性
>4.不同分辨率的界面下，验证登录页面的显示以及功能的正确性
>其他：
>1.针对不同场景下的登录失败，验证对应的错误信息展示（前端根据后端接口返回的错误信息回显给用户，未调用服务端接口的错误由前端处理）

>问：测试用例包含哪些内容（测试用例的格式）
>答：一条完整的测试用例应该包含用例编号、用例标题、前置条件、操作步骤、测试数据、预期结果、优先级等字段

>问：如何提升测试效率？
>答：
>>	1. 测试左移，测试人员提前介入测试，比如通过 mock 等方式开始接口测试
>>	2. 对于稳定的模块考虑自动化
>>	3. 严格遵守流程规范，让整个研发过程中的事情正确的执行，减少返工和无效沟通
>>	4. 进行过程质量把控，当研发过程质量提升，测试时间将大幅缩短
>>	5. 确保测试环境稳定可用，尽量仿真生产环境
>>	6. 持续集成与持续交付

>问：上一家公司的工作你觉得对你个人而言有哪些方面的成长？
>答：当时回答的时候考虑的不够全面，复盘一下我觉得可以从以下几个方面展开描述
>1. 硬性技能：
>   >	1. 对于业务需求的理解能力和思考会更深入和全面
>   >	2. 工作经验的积累对一些功能点提前预判可能存在的问题或者风险
>   >	3. 关于产品质量的保障认识的维度提升，如更全面的去跟进项目研发过程，而不是被动的做一个执行者
>   >	4. 对于自动化有一个正确的认识，而不是盲目的去做一个落地，要考虑具体的阶段和项目特性
>   >	5. 可以更高效的和售后、运营、用户进行产品相关问题的沟通
>   >	6. 技术的广度增加了，如之前工作中对于自动化的设计和实现都是基于Python语言及其生态的一些框架工具，在上一份工作中接触了基于Java生态的一些框架，可以针对以上不同语言来开展自动化测试的落地
>   >	7. 养成了复盘总结和记录的习惯
>2. 软性素质：
>   >	1. 高效的完成跨部门沟通和协作
>   >	2. 对于项目上面的一些风险和问题及时跟进处理和反馈
>   >	3. 有序的时间管理，确定工作时间和方式，做好工作记录
>   >	4. 解决问题的能力
>   >	5. 适应能力
>   >	6. 组织和表达能力
****
#### 测试流程
>问：你们公司的测试流程是怎么样的？
>答：熟悉需求文档、参与需求评审和技术评审、测试分析（1⃣️根据需求提取功能点，确定测试范围2⃣️对独立功能进行分析，确定各独立功能的测试点3⃣️对功能组合进行分析，提供业务场景的测试点4⃣️分析分功能特性，了解测试对象的非功能特性）、测试用例设计、组织测试用例评审、提测之后的冒烟测试、冒烟通过后执行测试用例、缺陷的提交与回归测试、系统集成测试、通知产品/设计验收、发布生产环境、出具测试报告、项目复盘（如有需要）
>****
#### 测试文档
>问：测试过程中会产生哪些文档？
>答：不同的测试阶段会产生其对应的文档。
>分析设计阶段：测试计划、测试方案
>测试执行阶段：冒烟测试报告、测试报告
>总结阶段：复盘报告

>问：测试计划包含哪些内容？
>答：分为几个阶段去写
>>1.前期准备：包括了测试资源分配、测试准备工具和测试数据
>>2.确定测试范围：被测对象、测试内容
>>3.确定测试策略：功能测试、兼容性测试、交叉测试、接口测试等等
>>4.提测准备：验收时间、提测时间、测试时间、发布时间
>>5.沟通点：提测范围、改动范围、是否有延期提测的功能、是否有风险点
>>拓展问题，做好测试计划的关键点？
>>目的、管理、规范

>问：测试方案包含了哪些内容？
>答：项目背景、测试环境、测试软硬件资源、测试策略、测试风险分析、测试范围、测试用例设计、测试报告

**缺陷相关**
>问：一个缺陷包含哪些内容？

>答：一个完整的缺陷应该包含标题、问题描述或总结、前置条件、测试数据、测试步骤、测试结果（期望结果和实际结果）、缺陷等级、缺陷优先级、项目信息（归属项目、版本号、模块）、缺陷分类、责任人、附件（如有）
>****

### 项目介绍
一般会让你简单介绍一下简历中所写的项目。以下总结了一些面试官常用的提问方式：
| 方式                                                                                                 | 目的                                                                 |
| ---------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------- |
| 让你描述工作经验和项目（最近或最熟悉的），看看你说的是否和简历上一致                               | 看你是否真的做过这些项目|
| 看你简历上项目里用到的技术，比如框架、数据库，然后针对这些技术提些基本问题                           | 还是验证你是否做过项目，同时看你是否了解这些技术，为进一步提问做准备 |
| 针对某个项目，不断深入地问一些业务上的问题，或者从不同侧面问一些技术实现，看你前后回答里面是否有矛盾 | 深入核实你的项目细节|
| 针对某技术，问些项目里一定会遇到的问题，比如候选人说做过数据库，那么就会问索引方面的问题|通过这类问题，核实候选人是否真的有过项目经验|

**项目描述**
- 表达能力：考察表达及逻辑思维能力，看面试者能不能在几分钟就跟一个完全没有参与过项目的人讲清楚这个项目
- 实际工作经验：你在项目中中承担了什么角色，做了什么工作。这些工作中的技术含量及跟同事合作情况如何。另外可能会针对某个项目，不断深入问一些技术上的问题，或者是从侧面问技术类实现，这是为了深入核实你做项目的细节及对技术的理解运用
- 解决问题的能力：一般都会问项目难点，其实就是想知道当你遇到技术或业务难点，是如何思考并解决问题的
  
**面试技巧**
- 项目概述：用通俗易懂且简洁的方式简述项目，阐述整个项目及其背景、规模，不要有太多的技术词
- 项目模块：2-3分钟的流程介绍，详细的列出项目实现的功能，各个模块，整个过程，大概思路
- 项目技术栈：说出项目实现的技术栈和架构，能说出项目的不寻常之处，比如采用了某项新技术，采用了某个架框等，简要说明技术选型
- 候选人的角色及责任：说出你在项目中的责任，所涉及的功能模块，运用的技术，碰到的难题、代码细节，技术点、应对措施
- 项目总结：待优化点

**面试方法：**
可以使用万能的STAR原则
- Situation（背景）：做这个项目的背景是什么，比如这是个人项目还是团队项目，为什么需要做这个 项目，你的角色是什么，等等。  
- Target（目标）：该项目要达成的目标是什么？为了完成这个目标有哪些困难？  
- Action（行动）：针对所要完成目标，你做了哪些工作？如何克服了其中一些困难？  
- Result（结果）：项目最终结果如何？有哪些成就？有哪些不足之处可以改进？

**表达方式**
- 项目：先说业务逻辑，再说业务逻辑背后的架构或者数据流
- 亮点：你在项目中担任的角色以及负责的模块，运用了什么工具/方法/流程，解决了什么问题，为团队带来了什么收益，最好提供可量化的数据
- 细节：熟悉简历上面的每个技术点，引导面试官问向自己熟悉的领域

**项目实例**
以云办税项目举例：
- 背景：云办税这个项目的背景就是在疫情的影响下，将用户需要去办税大厅办理业务的操作迁移至线上办理。是一个以视频咨询和大厅业务云办理的在线税务办理应用
- 业务流程：
	- 用户端：用户通过钉钉或者微信等渠道进入应用，然后可以选择发起视频咨询或者业务办理工单的申请。再由对应的税管员处理咨询，直至业务办结成功
	- 受理员：进入工作台处理用户发起的视频咨询或者业务办理申请，对用户发起的工单做一个受理、退回、转交、办结、不予受理等操作。
	- 组织运营人员：进入管理后台创建办税大厅，税厅的配置（业务配置和受理员配置）、业务库的管理和业务数据的查看
	- 中台：负责配置已开启云办税业务组织的配置（是否开启实名认证、实名认证方式、配置电子签章、视频咨询是否对接其他应用）
- 数据流
	- 数据流通过钉钉/微信作为入口，通过网络传输、解析（tcp/dns）
	- 将请求信息通过 http 发送至网关（nginx），然后 nginx 负载到对应后端服务商
	- 通过查询 redis 上获取关键信息（用户），经过业务系统处理后，生成工单信息存储至 msql 中
	- 结果数据返回至前端（视频咨询/工单发起成功）
- 项目的亮点和难点
	- 亮点
	>	1. 前期：
	>	   全链路业务质量保证，拆解每个环节的业务场景，确保业务场景都能覆盖到
	>	2. 中期
	>	   在前后端联调前通过接口文档完成接口测试，提前介入以缩短测试周期
	>	3.后期：
	>	   通过自动化测试框架 testng，覆盖业务接口测试达到 90%以上
	>	4. 收益：
	>	   因为完成接口测试以及自动化的覆盖大大提升了测试效率，发布时间由原来的半个月一次缩短到 1 周一次。
	>	5. 总结：业务场景如何设计，例如：受理员受理工单的场景设计，对自己的业务场景要非常熟悉，从功能、性能、安全、易用性等方面去考虑测试场景的设计
	- 难点
	>	1.问题：项目迭代过程中遇到的技术问题基本都可以解决，但是比较大的难点就是测试时间与产品质量的矛盾。因为开发经常存在延期提测和冒烟测试不通过的情况。
	>	2. 如何解决：第一是提升测试效率。第二是推进落实更合规的项目研发流程。

****
### Mysql
**理论相关**
个人感觉不太会问到，大概了解一下即可。
- DML（data manipulation language）：它们是select、update、insert、delete，是用来对数据库里的数据进行操作的语言
- DDL（data definition language）：常用的 create、alter、drop 等，主要用在定义或改变表的结构、数据类型、表之间的链接和约束等初始化工作上，大多在表建立的时候使用
- DCL（Data Control Language）：数据库控制功能。是用来设置或更改数据库用户或角色权限的语句，包括（grant,deny,revoke等）语句
****
**DDL相关问题**
不以问答形式展示了，直接总结一些常用的吧（表名称我们就用最常见的user表）
>1.创建数据库：create database user;
>2.查看数据库列表：show database;
>3.删除数据库：drop user;
>4.查看表设计：1⃣️desc user; 2⃣️show create table user;
>5.清空表：1⃣️truncate table user; 2⃣️delete from user;
>6.删除字段：alert table user drop username;
>7.新增字段：alert table user add username varchar;
>8.修改字段类型：alert table user modify username int;
>9.修改字段：alert table user change username name varchar;
>10.创建索引：alert table user index 索引名(字段1,字段2);
>11.创建主键索引：alert table user add primary 索引名(字段1,字段2);
>12.查看索引信息：show index from user;
>13.删除索引：alert table user drop index 索引名;

**** 
**DML相关**
>常用查询
>	1.查询结果去重：
>	`select distinct 字段名 from 表名`;
>	2.取5～10条数据：
>	`select * from user limit 5 offset 10;`
>	3.根据年龄倒序：
>	`select * from user order by age desc;`
	4.数据过滤(or、and、in、not in、between…and)
>>4.1 查询年龄为20或体重120且分数大于80的用户信息：
>>`select * from user where score >90 and (age=20 or weight=120);`
>>4.2 查询分数为60、80、90的用户：
>>`select * from user where score in (60,80,90);`
>>4.3 查询年龄在6～12岁之间的用户：
>>`select * from user where age between 6 and 12; `
	5.模糊匹配(like)
>>5.1 姓张的用户：
>>`select * from user where name like '张%';`
>>5.2 名字以杰结尾的用户：
>>` select * from user where name like '%杰';`
>>5.3 名字包含流的用户：
>>`select * from user where name like '%流%';`
>>5.4 表示任意单个字符：
>>`select * from user where name like '张_';`
	6.正则匹配
>>6.1 名字以王开头：
>>`select * from User where name regexp '^王';`
>>6.2 名字以蛋结尾：
>>`select * from User where name regexp '蛋$';`
>>6.3 匹配任意一个字符：
>>`select * from User where name regexp ".万";`
>>6.4 用户名以万、孟开头：
>>`select * from User where name regexp '^[孟,万]';`
	7.内置函数(avg、count、max、min、sum)
>>7.1 查询年龄大于12的用户的平均分：
>>`select avg(score) as “平均分” from user where age > 12;`
>>7.2 返回行数：
>>`select count( * ) from user;`
>>7.3 返回年龄的最大值：
>>`select max(age) from user;`
>>7.4 返回年龄的最小值：
>>`select min(age) from user;`
>>7.5 求和：
>>`select sum(score) from user where score < 60;`
	8.分组(group by、having)
>>8.1 以某个字段分组：
>>`select * from user group by age;`
>>8.2 having过滤分组，查询用户的姓名和平均分，根据用户名分组，且平均分要大于60：
>>`select username, avg(score) as avg_score from user group by username having avg_score > 60;`

	sql语句执行顺序：
	1.from:组装来自不同数据源的数据
	2.where：基于指定的条件对记录进行筛选
	3.group by：子句将数据划分为多个分组
	4.使用聚合函数进行计算
	5.使用having子句筛选分组
	6.计算所有表达式
	7.select的字段
	8.使用order by对结果进行排序
	9.使用limit展示需要的行数
数据库事务的四大特性（简称ACID）：
- 原子性：要么全部完成，要么不完成，若发生错误会进行回滚操作
- 一致性：开始到结束后，数据库完整性约束没受到破坏
- 隔离性：事务与事务之间相隔离，串行化执行
- 持久性：事务完成对数据的影响是永久的

主键与外键：
- 主键：对表中数据进行唯一标识的数据列的组合；不能缺失；不能空值；
- 外键：该列为另一张表的主键

>问：数据库索引是什么，简单说说索引的优缺点？

>答：索引是指数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据
>优点：1⃣️大幅提高系统性能,帮助用户提高查询的速度 2⃣️通过索引的唯一性，可以保证数据库表中的每一行数据的唯一性 3⃣️可以加速表与表之间的链接 4⃣️降低查询中分组和排序的时间
>缺点：1⃣️索引的存储需要占用磁盘空间 2⃣️提高了查询速度，但降低了更新表的速度

>问：mysql有哪些关联查询的种类，分别代表什么意思？

>答：左连接（left join）、右连接（right join）、内连接（inner join）、全连接（full join）
>>左连接：A left (outer) join B, 以 A 表为基础，A 表的全部数据，B 表有的组合，没有的为 null
>>右连接：A right(outer) join B, 以 B 表为基础，B 表的全部数据，A 表有的组合，没有的为 null
>>内连接：两表都满足的组合。内连接分为等值连接，不等连接，自然连接
>>全连接：A full (outer) join 两表相同的组合在一起，A 表有，B 表没有的数据（显示为 null），同样 B 表有，A 表没有的显示为 null

主从备
- 主库
- 从库
- 备库

存储过程

触发器
>问：数据库优化了解过吗，可以从哪些方面入手？
>答：分为软件和硬件两个方面
>软件方面优化：1⃣️分库分表 2⃣️添加索引 3⃣️sql 调优 4⃣️表结构优化 5⃣️读写分离 6⃣️数据库集群
>硬件方便优化：todo

**真题模拟**
![](https://s2.loli.net/2023/02/04/7HxC21oMJmf3AeL.png)
现有表user和department，他们之间用部门id关联
>问：使用单次查询返回每个部门中年龄最大的用户信息，如果年龄一样大则都返回，如图三的结果数据

>	答：思路就是先根据用户和部门关联查询，然后根据部门id分组，但是max聚合函数当age一样的时候只会返回一条数据，需要对年龄一样的的情况做特殊处理，我们就可以先把上面拿到的最大年龄数据当作条件，外面在套一个查询即可。
>	SELECT a.NAME AS "姓名", b.department_name AS "部门", a.age AS "年龄" FROM user2 a LEFT JOIN department b ON a.department = b.department_id WHERE a.age IN ( SELECT max( c.age ) FROM user2 c LEFT JOIN department d ON c.department = d.department_id GROUP BY c.department);
****
### Web测试
>问：一个url（统一资源定位符）包含哪些部分？
>答：例如https://www.tester.com/userlist?age=10#xx
>协议、主机、端口、路径、查询参数、锚点

>问：简述一下浏览器访问一个URL地址的过程？
>答：1⃣️缓存查找 2⃣️dns解析 3⃣️负载均衡和污染 4⃣️建立tcp连接(3次握手) 5⃣️客户端发送http请求 6⃣️服务器处理请求 7⃣️浏览器解析网页 8⃣️客户端关闭tcp连接，4次挥手结束，完成整个访问过程

代理服务器相关
- nginx：是一个高性能的 HTTP 和反向代理服务器，也是一个 IMAP/POP3/SMTP 服务器
- apache：是一个模块化的服务器，源于 NCSAhttpd 服务器
- tomcat：是一个免费的开放源代码的 Web 应用服务器，属于轻量级应用服务器，是开发和调试 JSP 程序的首选

>问：nginx了解吗，有什么优点和哪些应用场景？

>答：nginx是一个高性能的 HTTP 和反向代理服务器。具有跨平台、非阻塞高并发连接、内存消耗小、稳定性高、成本低且开源、内置健康检查功能等优点。
>应用场景有http服务器、虚拟主机等

- 正向代理：代理端代理的是客户端
- 反向代理：代理端代理的是服务端
- nginx限流
	- 限流策略
		- 正常限制访问频率
		- 突发限制访问频率
		- 限制并发连接数
	- 算法
		- 漏桶
		- 令牌桶

- 登录鉴权
	- 认证（Authentication）：通俗地讲就是验证当前用户的身份，证明”你“是你自己
		- 互联网中的认证：
			- 用户名密码登录
			- 邮箱发送登录链接
			- 手机号接收验证码（只要你能收到邮件/验证码，就默认你是当前账号的主人）
	- 授权（Authentication）：在安装应用或者访问小程序时的弹窗询问信息。如在安装手机应用的时候，APP 会询问是否允许授予权限（访问相册、地理位置等权限），在访问微信小程序时，当登录时，小程序会询问是否允许授予权限（获取昵称、头像、地区、性别等个人信息）
		- 实现授权的方式
			- cookie
			- session
			- token
			- oauth
	- 凭证（Credentials）：实现认证和授权的前提是需要一种媒介（证书） 来标记访问者的身份。商鞅住店的照身贴、现代的身份证。在互联网中则体现为一些网站支持游客模式和登录模式，游客模式下，可以正常浏览网站上面的文章，一旦想要点赞/收藏/分享文章，就需要登录或者注册账号。当用户登录成功后，服务器会给该用户使用的浏览器颁发一个令牌（token），这个令牌用来表明你的身份，每次浏览器发送请求时会带上这个令牌，就可以使用游客模式下无法使用的功能。

>问：什么是cookie，有哪些特性？
>答：因为http是无状态的协议，所以需要使用cookie记住每个用户的会话信息。
>cookie存储在客户端且是不可跨域的。

>问：什么是session，使用session认证的流程是什么样的？
>答：session是基于cookie实现的，session存储在服务端，sessionid会被存储在客户端的cookie中，session是另一种记录服务器和客户端会话状态的机制。
>>认证流程：
>>1.用户首次请求服务器时，服务器根据用户信息创建对应session
>>2.请求返回时将该session对应的唯一标识信息sessionid返回给浏览器
>>3.浏览器收到后将sessionid存储到cookie中，同时cookie记录sessionid属于那个域名
>>4.当用户第二次访问时，会自动判断此域名下面是否存在cookie信息，如有就会自动将cookie信息发送给服务端，服务端会从cookie中获取sessionid，在根据id获取session信息。如果没有说明没有登录或登录失败，需要重新走流程

>问：cookie和session有什么区别？
>答：cookie和session有以下几个方面的区别：
>>1.安全性：
>>session比cookie安全，session时存储在服务端的，cookie时存储在客户端
>>2.存取值类型不同：
>>cookie只支持字符串数据，想要设置其他类型的数据需要转换成字符串，session可以存任意数据类型
>>3.有效期不同：
>>cookie可设置长时间保持，session一般失效时间较短，客户端关闭或者session超时都会失效
>>4.存储大小不同：
>>单个cookie保存的数据不能超过4kb，session可存储数据远高于cookie，但是当访问量过多，会占用过多的服务器资源

>问：简单描述一下token，以及其认证流程时怎么样的？
>答：token其实分为两种，一种是access token，另一种时refresh token。
>>token:
>>是访问资源接口（api）时所需的资源凭证。由uid、time、sign、组成，其特点是服务端无状态化、支持移动端设备、安全、支持跨程序调用。
>>认证流程：
>>1.客户端使用用户名密码请求登录
>>2.服务端收到请求验证用户名密码
>>3.验证通过后签发一个token并把这个token发送给客户端
>>4.客户端收到后会把他存储起来，比如放到cookie或local storage中
>>其他知识点：
>>1.每次请求都要携带token，需要把token放到http的header中
>>2.基于token的用户认证是一种服务端无状态的认证方式，服务端无需存储token数据。用解析token的计算时间换取session数据的存储空间（记住token和session区别中有一个好记忆的点就是token是用时间换空间），从而减轻服务器的压力，减少频繁的查询数据库
>>3.token完全由应用管理，所以他可以避开同源策略（协议，域名，端口都相同,就是同源, 否则就是跨域）
>>refresh token：专用于刷新accesaccess token的token。因为access token有效期比较短，当由于过期而失效时，使用refresh token就可以获取到新的token，从而保持长时间的登录状态

>问：token和session的区别有哪些？
>答：token无状态化：
>>session是一种记录服务器和客户端会话状态的机制，使服务端有状态化，可以记录会话信息。而token是令牌，是访问服务端资源所需的资源凭证。使服务端无状态化，不存储会话信息
>
>token更安全：
>>session和token并不冲突，作为身份认证token安全性比session好，因为每一个请求都有签名还能防止监听以及重放攻击。而session就必须依赖链路层来保障通讯安全
>
>第三方共享：
>>如果你的用户数据需要和第三方功效，或者允许第三方调用api接口，使用token

**JWT**
>概述：
>全称JSON Web Token（简称 JWT）是目前最流行的跨域认证解决方案，是一种认证授权机制
>认证流程：
>>1.用户登录成功后返回客户端一个jwt
>>2.客户端将jwt保存在本地（cookie、local storage）
>>3.请求访问受保护的路由活着资源的时候，在请求头的authorization中使用bearer模式添加jwt
>其他：
>>1.服务端的保护路由将会检查请求头 Authorization 中的 JWT 信息，如果合法，则允许用户的行为
>>2.因为 JWT 是自包含的（内部包含了一些会话信息），因此减少了需要查询数据库的需要
>>3.因为 JWT 并不使用 Cookie 的，所以你可以使用任何域名提供你的 API 服务而不需要担心跨域资源共享问题（CORS）
>>4.因为用户的状态不再存储在服务端的内存中，所以这是一种无状态的认证机制

>问：jwt和token的区别是什么？
>答：token-服务端验证客户端发送过来的token时还需要查询数据库获取用户信息，然后验证token是否有效，jwt-将token和payload加密后存储于客户端，服务端只需要使用密钥破解进行校验即可，不需要查询活着减少查询数据库，因为jwt中包含了用户信息和加密的数据

>问：什么是跨域，有哪些解决方案吗？
>答：跨域就是因为浏览器的同源策略导致它不能执行其他网站的脚本，是浏览器对js搞的安全策略
>解决方案：jsonp、cors、nginx做反向代理、node代理

>问：什么是cdn，作用是什么？
>答：cdn就是内容分发网络，是通过现有的intent中增加一层新的网络架构，将网站内容发布到最接近用户的网络边缘，是用户可就近访问所需内容，提高访问速度

**websocket**
>概述：
>>1.一种网络传输协议，位与 OSI 模型的应用层。可在单个 TCP 连接上进行全双工通信，能更好的节省服务器资源和带宽并达到实时通讯
>>2.客户端和服务器只需要完成一次握手，两者之间就可以创建持久性的连接，并进行双向数据传输
>>3.websocket 服务器与客户端通过握手连接，连接成功后，两者都能主动的向对方发送或接收数据
>
>特点：
>>1.全双工（通信允许数据在两个方向上同时传输，它在能力上相当于两个单工通信方式的结合。例如指 A→B 的同时 B→A ，是瞬时同步的）
>>2.二进制帧（采用了二进制帧结构，语法、语义与 HTTP 完全不兼容，相比http/2，WebSocket 更侧重于“实时通信”，而HTTP/2 更侧重于提高传输效率，所以两者的帧结构也有很大的区别。不像 HTTP/2 那样定义流，也就不存在多路复用、优先级等特性，自身就是全双工，也不需要服务器推送
>>3.协议名（引入ws和wss分别代表明文和密文的websocket协议，且默认端口使用80或443，几乎与http一致）
>>4.握手（WebSocket 也要有一个握手过程，然后才能正式收发数据）
>
>优点：
>>1.较小的控制开销
>>2.更强的实时性
>>3.保持创建连接
>>4.更好的二进制支持
>>5.支持拓展
>>6.更好的压缩效果
>
>应用场景：
>>1.弹幕
>>2.媒体聊天
>>3.协同编辑
>>4.基于位置的应用
>>5.体育实况更新
>>6.股票基金报价实时更新
****
### App测试
**app分类**
>1.native app：
>原生程序，一般运行在机器操作系统上，有很强的交互，一般静态资源都是在本地的。浏览使用方便，体验度高
>2.hybrid app：半原生程序，伪造了一个浏览器的apk/ipa原生程序，把地址写死了，然后里面运行了一个web app。里面是WebView UI 。但是还是运行在机器的操作系统上，交互较弱，资源一般在本地或者网络都可以。浏览体验度次之
>3.react native app：Facebook发起的开源的一套新的APP开发方案,使用JS+部分原生语法来实现功能。初次学习成本较高,但是在入门后,经过良好的封装也能够实现大部分的跨平台。而且体验很好
>4.web app：生存在浏览器里的应用，所以只能运行在浏览器里，宿主是浏览器，不再是操作系统。资源一般都在网络上。说的根本点就是一个触屏版的网站

**不同分类app优缺点**
>native:
>>优点：
>>1.体验好、优质的界面和交互
>>2.针对不同平台提供不同体验
>>3.可访问本地资源
>>4.直接访问系统api
>>5.操作响应快
>>6.用户留存高
>>缺点：
>>1.成本高（多版本、多平台）
>>2.发布新版本需要审核
>>3.盈利与三方分红
>>4.更新体验差
>
>hybrid:
>>优点：
>>1.开发成本低，可以跨平台，调试方便
>>2.维护成本低，功能可复用
>>3.可以通过原生提供api,进行资源主动下载,达到只更新资源文件,不更新apk(ipa)的效果
>>4.功能更加完善,性能和体验要比起web app好
>>缺点：
>>1.相比原生性能损耗大
>>2.这种模式受限于webview的性能桎梏,相比原生而言有不少损耗,体验无法和原生相比。不适用于交互性较强的app
>
>react native:
>>优点：
>>1.性能体验高于Hybrid,不逊色与原生
>>2.虽然说开发成本大于Hybrid模式,但是小于原生模式,大部分代码可复用
>>缺点：
>>1.虽然可以部分跨平台,但并不是Hybrid中的一次编写,两次运行那种,而是不同平台代码有所区别
>>2.这种模式实际上还是JS来写原生,所以Android和iOS中的原生代码会有所区别,如果需要跨平台,对开发人员有一定要求
>>3.开发人员学习有一定成本
>
>web:
>>优点：
>>1.开发成本低，更新快，无需用户手动升级
>>2.跨平台和终端，维护简单
>>缺点：
>>1.临时的入口，用户留存率低
>>2.无法获取系统级别的通知、提醒等功能
>>3.需要依赖网络，体验较差

>问：Android四大组件分别是那几个？

>答：1⃣️activity 2⃣️service 3⃣️broadcastrecevier 4⃣️contentprovider

**测试内容**
>1.功能测试：业务逻辑正确性测试（产品文档/测试用例）
>2.专项测试：
>>2.1 用户体验测试
>>2.2 网络测试
>>2.3 兼容测试
>>2.4 权限测试
>>2.5 安装/卸载/升级测试
>>2.6 性能测试（电量/流量/cpu/内存/启动时间）
>>2.7 稳定性测试（monkey）
>>2.8 安全性测试（密码加密/密码复制粘贴/sql注入）
>
>3.兼容性测试
>>3.1 系统兼容（Android/ios/Windows/macOS）
>>3.2 厂商兼容（miui/coloros/flyme）
>>3.3 分辨率兼容
>>3.4 网络兼容
>
>4.monkey测试
>>4.1 健壮性
>>4.2 稳定性
>>4.3 容错性
****

### Linux相关
- 常见的命令
	- 目录相关
	>	1. cd：目录切换
	>	2. 主目录：~/
	>	3. 查看当前路径：pwd
	>	4. mkdir：创建指定名称的目录
	>	5. du：显示目录或文件的大小
	>	6. df：显示每个文件所爱的文件系统的信息，默认是显示所有的文件系统
	- 查看信息
	>	1. who am i：查看之所在的终端信息
	>	2. who：查看当前谁在使用该主机
	>	3. ls -l（或者直接 ll）：列出长数据串，包含文件的属性与权限数据等
	>	4. ls-a：同上，可返回隐藏文件信息
	>	5. find -name 文件名：找匹配的文件名
	- 文件相关
	>	1. cp -a f1 f2：连同文件的所有特性把 f1 复制成 f2
	>	2. cp f1 f2 f3 test：把 f1、f2、f3 复制到 test 目录中
	>	3. mv f1 f2 f3 test：同上，不过是移动操作
	>	4. rm -rf dir：强制删除 dir 中的所有文件
	>	5. vi 文件名：编辑方式查看
	>	6. cat 文件名：显示文件的全部内容
	>	7. more 文件名：分页显示文件内容
	>	8. less 文件名：与 more 类似，可以往前翻页
	>	9. head 文件名：仅查看头部，还可以指定行数
	>	10. tail -f test.log：查看正在改变的日志文件
	>	11. tail -3000 test.log：查看改文件的倒数前 3000 行
	>	12. which：只能查可执行文件
	>	13. whereis：只能查二进制文件、说明文档、源文件等
	- 系统相关
	>	1. df -hl：查看磁盘使用空间
	>	2. du -hl：查看文件夹的占用空间
	>	3. free：显示系统当前内存的使用情况，包括已用内存、可用内存和交换内存情况
	>	4. top：显示当前系统中占用资源最多的一些进程
	>	5. ps -ef|grep java：找出 Java 相关的进程
	>	6. kill -9 进程号：彻底杀死某个进程
	>	7. netstat -anp|grep port：查看某端口是否被占用
	>	8. chown -R：更改某个文件或目录的属主和数组
	>	9. shift+pageUp：翻页
	- 权限相关：
	>	1. chmod：改变文件的权限
	>	   语法：chmod[option] mode files
	>	   777：第一位指定属主的权限，第二位指定组的权限，第三位指定其他用户的权限。每位通过 4（读）、2（写）、1（执行）的和来确定权限，如 6（4+2）代表有读写权限，7（4+2+1）代表有读写执行的权限
	- 查询统计
	>	1. 统计单个字符串出现的次数：grep -o targetString fileName | wc -l
	>	2. 查询某个文件中的某个词：grep "error" fileName
	>	3. 子当前目录中查找 test：grep -r "test" .
	>	4. 查看文件里有多少行：wc -l fileName
	>	5. 删除一个文件中重复的行：uniq fileName
	>	6. 删除重复之后进行排序：sort fileName | uniq
****
### 工具相关
#### Git
#### JMeter
#### Postman
#### Charles
### 接口测试
**接口**
>概述：通常指的是前段和服务端的服务通讯接口，代码中的接口，如封装好的类
>协议：网络通信协议、http和https协议、websocket协议
>请求方式：get/post/delete/put/head/options
>mock测试：
>>概述：在测试过程中，对于某些不容易构造或者不容易获取的对象，可以用一个虚拟的对象来代替的测试方法
>>作用：
>>1.可以用来解除测试对象对外部服务的依赖，使得测试用例可以独立运行 
>>2.替换外部服务调用或一些速度较慢的操作，提升测试用例的运行速度
>>3.模拟异常逻辑，异常逻辑往往很难触发，通过Mock可以人为的控制触发异常逻辑
>>4.团队可以并行工作

**http协议**
>概述：
>>http：客户端和服务器端请求和应答的标准（TCP），用户从 www 服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少
>>https：HTTP 的安全版，即 HTTP 下加入 SSL 层，HTTPS 的安全基础是 SSL，因此加密的详细内容就需要 SSL

>问：http和https区别
>答：
>>1.https 协议需要到 ca 申请正数，一般免费证书较少，因此需要一定费用
>>2.http 是超文本传输协议，信息是明文传输，https 则是具有安全性的 ssl 加密传输协议
>>3.http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443
>>4.http 的连接很简单，是无状态的；https 协议是由 ssl+http 协议构建的可进行的加密传输、身份认证的网络协议，比 http 协议安全

>问：get和post请求方式有什么区别？
>答：
>>1.GET 提交的数据会放在 URL 之后，以?分割 URL 和传输数据，参数之间以&相连，如EditPosts.aspx?name=test1&id=123456. POST 方法是把提交的数据放在 HTTP 包的 Body 中
>>2.GET 提交的数据大小有限制（因为浏览器对 URL 的长度有限制），而 POST 方法提交的数据没有限制
>>3.GET 方式需要使用 Request.QueryString 来取得变量的值，而 POST 方式通过 Request.Form 来获取变量的值
>>4. GET 方式提交数据，会带来安全问题，比如一个登录页面，通过 GET 方式提交数据时，用户名和密码将出现在 URL 上，如果页面可以被缓存或者其他人可以访问这台机器，就可以从历史记录获得该用户的账号和密码

>问：http协议的特点有哪些？
>答：
>>1. 支持客户端/服务器模式
>>2. 简单快速（客户端向服务器发起请求时只需要传送请求方法和路径）
>>3. 灵活（允许传输任意类型的数据对象）
>>4. 无连接（限制每次连接只处理一个请求，服务器处理完客户端的请求并应答后就断开连接，可以节省传输时间）
>>5. 无状态（对于事务处理没有记忆能力，无状态意味着如果后续处理需要前面的信息，则必须重传，可能会导致每次连接传送的数据量增大）

>问：http原理是什么？
>答：
>>1. 客户端连接到web服务器
>>2. 发送一个http请求
>>3. 服务器接收请求并返回http响应
>>4. 释放tcp连接
>>5. 客户端浏览器解析html内容

>问：http协议响应码有哪些分类，常见的有哪些？
>答：常见状态码分类
>>`1xx:提示信息表示已接受请求，继续处理`
>>`2xx:表示请求已被成功接收、理解、处理`
>>`3xx:重定向，要完成请求必须进行更进一步的操作`
>>`4xx:客户端错误，请求有语法错误或请求无法实现`
>>`5xx:服务端错误，服务器未能实现合法的请求`
>
>常见的响应码
>>`200:OK，客户端请求成功`
>>`400:bad request，客户端请求有语法错误，不能被服务器理解`
>>`401:unauthorized，请求未经授权`
>>`403:forbidden，服务器收到请求，但是拒绝提供服务`
>>`404:not found，请求资源不存在`
>>`500:internal server error，服务器发生不可预期的错误`
>>`502:server unavailable:服务器当前不能处理客户端的请求，一段时间后可能恢复正常`

**接口测试点**
- 1.可用性测试
	- 1.1 根据约定的协议、方法、格式内容，传输数据到接口经处理后返回期望的结果
	- 1.2 接口功能是否正确实现
	- 1.3 返回值测试
	- 1.4 参数边界值、等价类测试
- 2.错误和异常处理测试
	- 2.1 输入异常值（空值、特殊字符、超过约定长度、错误的数据类型）
	- 2.2 输入错误的参数，接口能正确处理，并按预期响应
	- 2.3 多输入、少输入参数，接口能正确处理、并按预期响应
	- 2.4 错误的数据格式（如json传form）
- 3.安全性测试
	- 3.1 敏感数据是否加密传输
	- 3.2 返回数据是否含有敏感数据
	- 3.3 接口是否对传入的数据做安全校验（权限越界等）
	- 3.4 接口是否防恶意请求
- 4.性能测试
	- 4.1 接口的响应时间、并发处理能力、压测处理情况
	- 4.2 并发请求相同的接口（特别是post）
	- 4.3 接口响应时间是否在用户的接受范围内
	- 4.4 对于请求量大的接口做压测，确定最大的瓶颈点是否满足当前业务需要
****
### 自动化测试
>问：在公司如何落地自动化测试的？
>答：分为多个阶段
>	1. 确定自动化测试为哪个阶段服务？
>	   功能测试阶段、集成测试阶段、预发回归阶段、生产定时回归阶段
>	2. 自动化测试框架选项
>	   一般选择市面主流的语言和开源框架（社区大成熟、踩坑少，遇到问题可以快速找到对应的解决方案）
>	3. 独立开发搭建自动化项目（或者成立对应自动化测试小组，1~2 人），编写底层公共模块，完成实例代码的实现
>	4. 自动化测试内部宣讲会
>	   发起内部会议，测试团队成员和直接上级参与，演示自动化框架，拆分讲解大概实现过程和分层结构
>	5. 自动化测试推广
>	   当测试团队成员项目间隙或非特殊时期，每天抽出 1~2 小时编写自己负责业务模块的自动化用例，本地调试通过之后提交 PR（可以适当的做一些 kpi 的倾斜），遇到问题先自己尝试解决，无法解决的组内讨论解决思路和方案。需求类的统一收集和处理
>	6. 按月统计汇总自动化测试用例覆盖和执行结果

>问：自动化测试项目怎么分层的？
>答：目录分层有以下几种
>>1. 配置类
>>2. 驱动类
>>3. 工具类
>>4. 测试数据类
>>5. 测试用例类
>>6. 测试结果类

>问：测试数据的读取方式有哪些？
>答：
>>1.存mysql
>>2.yaml、ini、conftest等配置文件
>>3.csv

>问：接口自动化的设计思路？
>答：下图是对接口自动化框架实现方案画的一个通用架构
>![](https://s2.loli.net/2023/04/01/KwVGS5s92CMnJcU.png)
>核心模块详解：
>>	1. 环境配置
>>	   该阶段属于测试的前置准备工作，开始执行用例之前，框架会自动读取待执行环境的配置信息。可以通过配置不同环境的数据来实现执行不同环境的测试用例，TEST、PRE、PROD，可以准备三个对应名称的  YAML 文件存放不同的配置信息
>>	2. 用例管理
>>	   一个测试用例由测试数据、HTTP 请求、断言三部分组成
>>	   测试数据：用例是有数据来驱动的。需要准备正向、反向、异常的数据
>>	   HTTP 请求：包含域名、接口名称、请求体、请求头内容
>>	   断言：根据接口的返回值做断言，也可以根据 DB 的数据做断言
>>	   由以上内容可以得出一条自动化测试用例组成的元素包含：用例名称、接口名称、请求方式、请求参数、断言
>>	   用例管理介质：一般由 YAML 等格式文件来存储对应的测试用例和数据，或者通过 MySQL 来存储（方便后期搭建可视化界面的一个展示）
>>	3. HTTP 核心
>>	   Java：HttpClient，提供 GET/POST 等请求方法封装即可
>>	   Python：Request，提供 GET/POST 等请求方法封装即可
>>	4. 断言模块
>>	   如果有需要可以针对断言模块单独封装一些方法，减少项目中的重复代码
>>	5. 测试报告
>>	   使用 Allure 工具考科一生成测试结果数据，通过命令行来转换成对应的可视化界面
>>	6. 通知
>>	   结合钉钉群配置一个消息推送的方法，在用例执行完成之后在对应的项目组中/测试组发送一个测试结果的通知


**testng**
>问：testng中注解的执行顺序？
>答：
>>1. @BeforeSuite()
>>2. @BeforeTest()
>>3. @BeforeClass()
>>4. @BeforeMethod()
>>5. @Test()
>>6. @AfterSuite()
>>7. @AfterTest()
>>8. @AfterClass()
>>9. @AfterMethod()

>问：testng如何设置测试用例的优先级？
>答：可以通过在@test注解中添加priority字段并设置值来定义测试用例运行的优先级
>>1. @test(priority = x)
>>2. x默认0，0的优先级最高

>问：在testng中，如何定义分组？
>答：分组是testng中的一个属性，它允许你执行多个测试用例，可以在@test注解中添加group参数设置对应的分组信息，如果要运行对应分组的测试用例则需要在testng.xml中指定对应的suite

>问：什么是testng中的依赖项？
>答：当我们需要按特定的顺序运行测试用例时，则在testng中使用依赖的概念。
>testng使用两种类型的依赖项属性：
>1. DependsOnMethods,告诉testng该测试将依赖与哪些方法，以便那些方法在此测试方法执行之前执行)
>>	public class Login
>>	{
>>		@Test
>>		public void login()
>>		{
>>			System.out.println("Login page");
>>		}
>>		@Test(dependsOnMethods="login")
>>		public void home()
>>		{
>>			System.out.println("Home page");
>>		}
>>	}
>2. DependOnGroups,类似于DependsOnMethods属性。它允许测试方法取决于测试方法组，它在相关测试方法之前执行测试方法组
>>	public class Login
>>	{
>>		@Test(groups="before test")
>>		public void getUserInfo()
>>		{
>>			System.out.println("get user info.");
>>		}
>>		@Test(groups="before test")
>>		public void login()
>>		{
>>			System.out.println("login.");
>>		}
>>		// 使用dependOnGroups
>>		@Test(dependOnGroups="before test")
>>		public void getUserInfo()
>>		{
>>			System.out.println("login success.");
>>		}
>>	}

>问：什么是testng中的timeout？
>答：如果接口对响应时间敏感，我们可以使用test注解中的timeout设置超时时间来将测试用例标记执行失败
>>	// 单位：毫秒
>>	@Test(timeOut = 300)

>问：如果我想要测试用例执行多次如何设置？
>答：可以在测试方法的test注解中添加invocationcount参数来实现
>>	public class Login
>>	{
>>		@Test(invocationCount = 3)
>>		public void login()
>>		{
>>			System.out.println("login success.");
>>		}
>>	}

>问：testng.xml有哪些作用？
>答：
>>1. 定义了所有测试用例的执行顺序
>>2. 允许对测试用例进行分组，并可以根据要求执行
>>3. 执行所选的测试用例
>>4. 可以在套件级别实现监听器
>>5. 允许将testng框架和Jenkins等工具集成

>问：testng.xml可以给测试用例传递参数吗？
>答：可以
>>我们可以在运行时将值传递给测试方法，通过该文件发送参数值来实现。使用@Parameter注解
>>>	实例：
>>>	testng.xml:
![](https://s2.loli.net/2023/02/15/H5O93wRkEzABMYt.png)

>>>	loginTest.java:
>>>	public class Web
>>>	{
>>>		@Parameter({"userinfo"})
>>>		@Test
>>>		public void login()
>>>		{
>>>			System.SetProperty("webdriver.chrome.driver", "./chromedriver.exe");
>>>			WebDriver driver = new ChromeDriver();
>>>			driver.get("xxx/login.com");
>>>			driver.findElement(By.name("q")).sendKeys("userinfo");
>>>		}
>>>	}

>问：testng如果禁用测试用例？
>答：可以使用@test注解中的enable参数控制该用例是否执行

>问：什么是软断言和硬断言，两者有什么区别？
>答：
>>1. 软断言：如果testng在@test注解期间出错，则断言失败时会抛出异常，，并在assert语句之后继续下一个语句
>>2. 硬断言：同上的场景，在断言失败时将立即引发assert exception，并在assert语句后停止执行后续语句

>问：@listener注解有用过吗，一般适用于什么场景？
>答：TestNG提供了不同种类的侦听器, 每当事件触发时, 它们便可以执行不同的操作。 TestNG中使用最广泛的侦听器是ITestListener接口。 ITestListener接口包含诸如onTestSuccess, onTestfailure, onTestSkipped等方法。
>以下是可以实现的方案：
>>1. 如果测试用例失败, 那么侦听器应执行什么操作
>>2. 如果通过了测试用例, 那么侦听器应执行什么操作
>>3. 如果跳过测试用例, 那么侦听器应执行什么操作
>
>>	实例：
>>	public class TestLogin
>>	{
>>		@Test
>>		public void test_login_success()
>>		{
>>			Assert.assertTrue(true);
>>		}
>>		@Test
>>		public void test_login_fail()
>>		{
>>			Assert.asserTure(false);
>>		}
>>	}
>>	Listener.java
>>	public class Listener implments ITestListener
>>	{
>>		@Override
>>		public void onTestStart(ITestResult resule)
>>		{
>>			// todo
>>		}
>>		@Override
>>		public void onTestSuccess(ITestResult resule)
>>		{
>>			System.out.println("Success of test cases and its details are : "+result.getName());
>>		}
>>		@Override
>>		public void onTestFailure(ITestResult resule)
>>		{
>>			// todo
>>			System.out.println("Failure of test cases and its details are : "+result.getName());
>>		}
>>		@Override
>>		public void onTestSkipped(ITestResult resule)
>>		{
>>			// todo
>>			System.out.println("Skipped of test cases and its details are : "+result.getName());
>>		}
>>		@Override
>>		public void onTestFinish(ITestResult resule)
>>		{
>>			// todo
>>			System.out.println("Finish of test cases and its details are : "+result.getName());
>>		}
>>	}

>问：@factory注解有什么作用？
>答：当我们想通过一个测试类运行多个测试用例时，@factory可用于测试用例的动态执行。
>>	实例：
>>	testCase1.java:
>>	public class TestLogin1
>>	{
>>		@Test
>>		public void test1()
>>		{
>>			System.out.println("testcase 01")
>>		}
>>	}

>>	testCase2.java:
>>	public class TestLogin2
>>	{
>>		@Test
>>		public void test2()
>>		{
>>			System.out.println("testcase 02")
>>		}
>>	}

>>	Factory.java:
>>	public class Factory
>>	{
>>		@Factory
>>		public object[] getTestClasses()
>>		{
>>			Object tests[] = new Object[2];
>>			 tests[0] = new TestLogin1();
>>			 tests[1] = new TestLogin2();
>>			 return tests;
>>		}
>>	}

>问：@factory和@dataprovider注解有什么区别？
>答：
>>1. @factory：被注解的方法，作为对象工厂，强制返回一个对象数据object[]，以使用相同类的不同实例来执行同一测试类中存在的测试方法
>>2. @dataprovider：被注解的方法，强制返回一个二维数组object[][]作为另一个@test方法的数据工厂，根据dataprovider提供的数据多次执行测试方法

**unittest**
**pytest**

>问：unittest和pytest有哪些区别，为什么要选择pytest？
>答：
>>1. 首先pytest是可以兼容unittest的测试用例的，但是反过来是不可以的
>>2. 用例的创建：
>>>	1.测试类需要继承unittest.TestCase，测试函数必须以_test开头或_test结尾
>>>	2. 而pytest可以直接通过命名规范来判断是否是测试用例文件
>>3. pytest用例收集规则：
>>>	1. 文件以test_*.py 和 *_test.py
>>>	2. 以test_开头的函数
>>>	3. 以Test开头的类
>>>	4. 以test_开头的方法
>>3. setup和teardown的区别：
>>>	1. unittest使用setup和teardown作为用例的前置和后置，而且针对所有用例
>>>	2. pytest通过在函数前添加@pytest.fixture()装饰器；可以实现模块级、函数级、类、级、方法级的setup和teardown
>>4. 参数化的实现：
>>>	1. unittest参数化需要结合第三方库ddt来实现
>>>	2. pytest可以使用@pytest.mark.parametrize()装饰器来实现
>>5. 断言
>>>	1. unittest使用assertEqual、assertTrue等
>>>	2. pytest可以直接使用assert表达式
>>6. 用例执行
>>>	1. unittest可以通过加载testsuite执行部分测试用例
>>>	2. pytest通过@pytest.mark标记测试用例，执行的时候带上-m运行标记的用例（-m后面支持多个标签，可以使用and或者or）

**用例的前置和后置**
- setUp：@pytest.fixture
	- 优势：
	>	1. 命名方式灵活，不局限于setup和teardown
	>	2. conftest.py配置里可以实现数据共享，不需要import就可以自动找到fixture
	>	3. scope=“moudle”可以实现多个.py跨文件共享前置
	>	4. scope=“session”可以实现多个.py文件跨文件使用同一个session来完成多个用例
	- 参数列表：
	>	1. scope：可以理解为作用于，默认函数级（function），常见的还有class、module、package、sessiosession
	>	2. autouse：默认false，需要手动调用该fixture，设置为true则作用于内的测试用例都会自动调用
	>	3. name：默认装饰器的名称，统一模块的fixture互相调用建议写不同的name
	- 如何使用：
	>	1. 将fixture名称作为测试用例函数的输入参数
	>	2. 测试用例加上装饰器：@pytest.mark.usefixture(fixture_name)
	>	3. fixture设置autouse=true
	- 实例化顺序：
	>	1. 较高scope范围的fixture（session）在较低fixture（function、class）之前实例化（1、session 2、package 3、module 4、class 5、function）
	>	2. 相同作用于的fixture遵循测试函数中声明的顺序，并遵循fixture之间的依赖关系
	>	3. autouse=true的fixture将在显式使用（传参或装饰器）之前实例化
	>	4. 添加了@pytest.fixture，如果 fixture 存在循环依赖的话就需要使用函数传参的方式，不能直接用@pytest.mark.usefixtures()的方式，否则会不生效
- tearDown：fixture 使用 yield
	>	1. 用 fixture 实现 tearDown 并不是一个独立的函数，而是使用 yield 关键字来开启 tearDown 操作
	>	2. yield 实例
	>	   # 打开浏览器的 fixture
	>	   @pytest.fixture(scope="session")
	>	   def open():
	>		   # 会话前置操作 setUp
	>		   print("—打开浏览器—")
	>		   test = “测试变量是否返回”
	>		   yield test
	>		   # 会话后置操作 tearDown
	>		   print("—关闭浏览器—")
	>	 
	>	 # 输入账号密码的 fixture
	>	 @pytest.fixture
	>	 def login(open):
	>		 # 方法级别前置操作 setUp
	>		 print(f"输入账号，密码先登录{open}")
	>		 name = "test"
	>		 pwd = "123456"
	>		 # 返回变量
	>		 yield name, pwd
	>		 # 方法级别后置操作 tearDown
	>		 print("登录成功")
	>		 
	>		 # 测试用例
	>		 def test_login(login):
	>			 print("login 返回一个元祖：", login)
	>			 # 赋值
	>			 name, pwd = login
	>			 # 断言
	>			 assert "test" in name
	>			 assert "123456" in pwd
	>	3. 注意点：如果 yield 前面的代码，即 setUp 部分已经跑出异常了，则不会知行 yield 后面的 tearDown 内容。如果测试用例抛出异常，yield 后面的 tearDown 内容还是会执行
- 断言：只有一个 assert 表达式，用起来比较方便
- 测试报告：pytest.html、allure
- 失败重跑：pytest-rerunfailures
- 配置文件：
	- conftest.py
	- 一个专门存放 fixture 的配置文件，可以有多个
	- 配置文件注意点：
	>	1. pytest 默认读取文件中所有的 fixture
	>	2. 文件名称固定，不能改动
	>	3. 只对同一个 package 下面的所有用例生效
	>	4. 不同目录可以有自己的 conftest.py，一个项目中可以有多个
	>	5. 测试类中无需手动导入
- 跳过用例：
	- skip、skipif
	- 作用：
	>	1. pytest.mark.skip可以标记无法再某些平台运行的测试功能，或者期望失败的测试用例
	>	2. 希望满足某些条件才知行的测试用例，否则就会跳过运行该测试用例
	>	3. 实际场景：比如某个测试用例无法在非 chrome 浏览器中测试，或者跳过以来当前不可用的外部资源（db）
	- pytest.mark.skip(reson):
	>	1. reson为跳过原因，在执行结果中打印
	>	   # 作用于测试函数
	>	   @pytest.mark.skip("我是跳过的原因")
	>	   def test_login():
	>		   print("skip function!")
	>	   # 作用于测试类
	>	   pytest.mark.skip("我是跳过的原因")
	>	   class TestLogin:
	>		   print("skip class!")
	- pytest.skip()：
	>	1. 在测试用例知行期间强制跳过不再执行剩余内容
	>	2. allow_module_level=false：设置为 true 时，可以在模块级别跳过整个模块
	>	   # 示例
	>	   if sys.platform.startwith("win"):
	>		   pytest.skip("跳过非windwos平台的测试", allow_module_level=true)
	- pytest.mark.skipif(condition,reason="")
	>	1. 希望有条件的跳过某些测试用例
	>	2. 需要 condition为true时才会跳过
	>	   # 示例
	>	   @pytest.mark.skipif(sys.platform == 'win32',reason="跳过win32系统):
	>	   class TestSkipIf:
	>		   def test_skipif_func():
	>			   print("无法再 win32 上面运行")
	- 跳过标记：
	>	可以将 skip 和 skipif 条件赋值给变量以达到减少冗余代码的目的，提高代码健壮性
	>	# 打标记
	>	skipMark = pytest.mark.skip(reason="无法在Windows上运行")
	>	skipIfMark=pytest.mark.skipif(sys.platorm == 'win32',reason = "不能在win32上运行")
	>	
	>	class TestSkip:
	>		@skipMark
	>		def test_skipMark():
	>			print("使用标记的 skip")
	>			
	>		@skipIfMark
	>		def test_skipIfMark():
	>			print("使用标记的 skipif")
- 自定义标记（mark）：
	>	pytest 可以支持自定义标记，自定义标记可以把一个 web项目划分为多个模块，然后指定模块名称执行，如制定某些用例在 windows 下面执行，其他在 macos 下面执行
	>	# 自定义 mark
	>	@pytest.mark.win
	>	def test_win():
	>		print("跳过 windows")
	>	@pytest.mark.macos
	>	def test_macos():
	>		print("跳过 macos")
	>	
	>	# 在终端执行命令行 
	>	$ pytest -s -m win test_mark.py
- 参数化
	- @pytest.mark.parametrize：允许在测试函数或类中定义多组参数和 fixtures
	- 参数详解：
	>	def parametrize(self, argnames, argvalues, indrient=False, ids=None, scope=None):
	>	1. argnames：参数名称，逗号分割（arg1, arg2, arg3）,支持字符串和元祖
	>	2. argvalues：参数值列表，必须是列表，如[1, 2, 3]
	>	3. indirect：如果是 true，则把传进来的参数当做函数执行，而不是一个参数
	>	4. ids：测试用例的 id，接收一个字符串列表
	>	5. scope：如果指定，则表示参数的使用范围
	- 当装饰器@pytest.mark.parametrize装饰测试类时，会将数据集合传递给类的所有测试用例方法
	- 测试类或者测试函数支持装饰多个@pytest.mark.parametrize（用例数=a*b，a=2，b=3，用例数量就是 6 条）
- pytest.ini（配置文件）
	- pytest 配置文件可以改变 pytest 的运行方式，他是一个固定的文件，读取配置信息，按指定的方式去运行
	- 常用配置项
	>	1. marks：测试用例添加@pytest.mark.p0 装饰器，如果不添加对应选项至配置文件会有告警信息，我们可以在 pytest.ini文件中添加对应的 p0 marks：
	>	   markers = p0:重要的测试用例
	>	2. addopts：更改命令行选项，终端中直接输入 pytest 即可（后面会自动带上 addopts）
	>	3. log_cli：控制台实时输出日志，true 或 false（默认）
	>	4. norecursedirs：pytest 默认会递归当前目录以及所有子目录，使用该阐述可以简化搜索测试用例的工作。norecursedirs = util resource report(多个路径用空格隔开即可)
	>	5. 更改测试用例收集规则：python_files=test_*、python_classes=Test_* 、python_functions=test_*

>问：pytest 默认的测试用例执行顺序？

>答： ASCII
>>	pytest默认是根据项目下文件名称按ASCII 码去收集运行的，文件里的用例是根据从上往下按顺序执行的

>问：pytest 是否可以改变测试用例的执行顺序？

>答：可以
>>	可以利用 pytest-ordering 库，通过装饰器@pytest.mark.run(order=1)来进行控制，数字越小代表执行顺序越靠前，随后使用 pytest_collection_modifyitems 钩子函数来重新排序
>>	钩子函数：
>>	1. 是一种函数，在系统消息触发时，被系统调用
>>	2. 无需用户自己触发
>>	3. 使用时，直接编写函数体
>>	pytest_collection_modifyitems：是 pytest 中的钩子函数，用于测试用例的收集，且在测试用例手机完毕之后被调用，他有三个参数
>>	1. session：会话对象
>>	2. config：配置对象
>>	3. items：用例对象的列表，改变 items 里面用例的顺序就可以改变用例的执行顺序了
>>	用法：
>>	1. 在 conftest.py 中定义该函数的内容，可以对测试用例的执行顺序、测试用例的编码进行修改
>>	2. 修改用例执行顺序和剔除测试用例（可以根据 items 列表作调整）

**selenium**

>问：简单说一下你对于 ui 自动化测试的 PO 模式的理解，以及其有哪些优势？
>答：PO 模式是一个自动化测试的设计思想，本质是把一个页面当做一个对象，页面的元素看成对象的属性和行为，实现页面对象和测试用例分离。
>PO 模式一般分为三层：
>>	1. 基础层：封装一些最基础的方法（一般是BasePage.py）
>>	2. 页面对象层：元素定位，页面操作等
>>	3. 测试用例层：业务逻辑、数据驱动
>>	三者之间的关系：
>>	测试用例层调用页面对象层，页面对象层继承基础层
>
>优势：
>>	1. 当某个页面的元素发生变化，只需要调整该页面对象中的代码即可，测试用例无需修改
>>	2. 提供代码重用率。结构清晰，维护代码容易
>>	3. 测试用例发生变化时，不需要或者只需要修改少数页面对象代码

>PO 图示：
>![](https://s2.loli.net/2023/02/17/LxXNzAjei8q1Ysn.png)

>问：常见的定位方式有哪些？
>答：selenium 支持 8 种元素的定位方式。
>>	1. ID
>>	   说明：通过元素的 id 进行定位（唯一），是最方便的一种定位方式
>>	   用法：driver.find_element(By.ID, "id")
>>	   # 打开百度，定位搜索框，输入 test
>>	   driver = webdriver.Chrome()
>>	   driver.get("www.baidu.com")
>>	   driver.find_element(By.ID, "kw").send_keys("test")
>>	2. NAME
>>	   说明：通过元素的 name 值进行元素定位（允许不唯一）
>>	   用法：driver.find_element(By.name, "name")
>>	   # 打开百度，搜素 test
>>	   driver.find_element(By.NAME, "wd").send_keys("test")
>>	3. CLASS_NAME
>>	   说明：通过 class 属性来定位（有的元素没有 class 属性）
>>	   用法：driver.find_element(By.CLASS_NAME, "class_name")
>>	   # 打开百度，输入 test
>>	   driver.find_element(By.CLASS_NAME, "s_ipt").send_keys("test")
>>	4. TAG_NAME
>>	   说明：html 文档就是一个一个标签（tag）组成，因此这种定位方式就是通过标签名进行定位，效率比较低，一般不使用
>>	   用法：driver.find_element(By.TAG, "tag_name")
>>	5. LINK_TEXT
>>	   说明：与前面几个不同，这个是专门定位超链接文本的
>>	   用法：driver.find_element(By.LINK_TEXT, "link_text")
>>	   # 打开百度搜索，点击百度地图
>>	   driver.find_element(By.LINK_TEXT, "百度地图").click()
>>	6. PARENT_LINK_TEXT
>>	   说明：对比 link_text就相当于模糊查询和精确查询的关系
>>	   用法：driver.find_element(By.PARENT_LINK_TEXT, "parent_link_text")
>>	   # 打开百度搜索，点击百度地图
>>	   driver.find_element(By.PARENT_LINK_TEXT, "地图").click()
>>	7. XPATH
>>	   说明：xpath 是 xml path 的简称，是一种用来确定 xml 文档中某部分位置的语言。在 selenium 中，xpath 是比较常用的且准确性极高的定位方式，它的定位方式也非常灵活。可以使用路径定位、元素属性定位、层级与属性定位
>>	   用法：driver.find_element(By.XPATH, ”xpath“)
>>	   # 打开百度搜索，输入 test
>>	   driver.find_element(By.XPATH, '//*[@id="kw"]').send_keys*("test")
>>	8. CSS_SELECOTR
>>	   说明：css（cascading style sheets）是一种语言，它用来描述 html 和 xml 的元素显示样式，css 语言中有 css 选择器，在 selenium 中也可以使用这种选择器来进行元素定位，相较于 xpath 速度更快，语言也更强大
>>	   语法：driver.find_element(By.CSS_SELECTOR, "css")

>问：webdriver 常用的api 有哪些？
>答：
>0. 
>> 1. webdriver.Chrome()：开启/关闭浏览器
>> 2. execute_script(js)：调用JavaScript
>1. 浏览器相关
>>	1. maximize_windwos()：最大化
>>	2. minimize_windows()：最小化
>>	3. set_winsow_size(w, h)：自定义
>2. 窗口相关
>>	1. forword：前进
>>	2. back：后退
>>	3. refresh：刷新
>>	4. switch_to.new_windwos：打开新的tab 页
>>	5. title：获取标题
>>	6. curent_url：获取当前页面的 url
>>	7. page_source：获取页面源码
>3. 元素定位操作
>>	1. click：点击
>>	2. clear：清除
>>	3. send_keys(value)：输入
>>	4. text：获取元素文本值
>>	5. get_attribute：获取元素指定的值
>4. 多窗口处理
>>	1. current_windwos_handle：获取当前窗口的句柄
>>	2. windwos_handles：获取已打开的所有窗口的句柄
>>	3. switch_to.window(handle)：通过句柄，切换到指定窗口
>5. 多框架处理
>>	1. switch_to.frame(ele)：切换到指定框架
>>	2. switch_to.default_content：切换到最外层框架
>>	3. switch_to.parent_frame：切换到上层框架
>6. 警告窗口处理
>>	1. 类型：
>>	   alert：只有确定按钮
>>	   confirm：有确定、取消按钮
>>	   prompt：有输入框、确定、取消按钮
>>	2. switch_to.alert.text：获取警告框中的文本信息
>>	3. switch_to.alert.accept：在警告框中点击确定
>>	4. switch_to.alert.dismiss：在警告框中点取消
>>	5. switch_to.alert.send_keys(value)：在警告框中输入内容
>7. 下拉框处理
>>	1. options：返回下拉框中的所有选项
>>	2. select_by_index(i)：通过索引选择下拉框列表
>>	3. select_by_value(v)：通过输入的 value 属性值选择
>>	4. select_by_visible_text(v)：通过输入的文本值选择
>8. 截图
>>	1. save_screenshot(file)：对当前页面截图，并保存为指定文件 file
>>	2. get_screenshot_as_file(file)：对当前页面截图，并保存为
>>	3. 两者没什么区别，save_screenshot 方法本质上还是 return self.get_screenshot()方法
>>![](https://s2.loli.net/2023/02/19/FbOxsIwy86r41DE.png)

>问：selenium有哪些等待的方法，有哪些区别？
>答：等待方法一共有三种，分别是强制等待、显示等待和隐式等待
>>	1. 强制等待：sleep（n），强制等待 n 秒
>>	2. 显示等待：WebDriverWait(driver, timeout)，针对某个元素的等待，在设置时间内，每隔一段时间检查一次，如果没有找到则返回异常，默认的检测频率为 0.5 秒
>>	3. 隐式等待：implicitly_wait(n)，设置的全局等待。设置后针对的是页面中所有元素设置加载时间。简单理解在设置时间内，浏览器不断刷新页面，直到找到相关元素或时间结束

>问：Web UI 自动化测试设计？
>答：架构图基本与接口自动化的框架类似，新增了对页面元素的封装，最近有一个组件层比较热门，也可以引入尝试一下。会有 config、basePage、component、tools、page、log、case、data、result 等模块
>核心分层详解：
>>	1. BasePage：封装对网页的一些基础操作的方法，比如打开浏览器、查找元素、输入、截图等
>>	2. Componet：继承自 BasePage 层，封装了对页面中对公共组件的操作方法，比如时间组件
>>	3. Page：继承自  Componet 层，该层中的每个方法都对应当前页面的一个功能，方法里可以调用组件层中的方法或调用 BasePage 层中封装的方法
>>	4. Case：调用业务 Page 层中封装的方法，编写业务 case，并作断言和日志输出
项目目录树
```
├── basepage
│   └── base_page.py
├── component
│   └── element_design.py
├── conf
│   ├── conf.py
├── datas
├── log
│   └── all.log
├── log.py
├── page
│   ├── home_page.py
│   ├── login_page.py
│   ├── main_page.py
│
├── pytest.ini
├── report
│  
├── requirements.txt
├── run_all_cases.py
├── testcase
│   ├── conftest.py
│   ├── testcase.py
│
└── util
    └── util.py
```

链式调用：
**appnium**
****
### Python基础
**数据类型**
- 可变类型
  >	可变类型指的是对应变量的值发生了改变，那么它对应的内存地址也会发生改变
  >	1. 字典（dict）
  >	2. 集合（set）
  >	3. 列表（list）
- 不可变类型
  >	不可变类型指的是对应变量的值发生了改变，那么它对应的内存地址不会改变
  >	1. 整型（int）
  >	2. 浮点型（float）
  >	3. 布尔型（bool）
  >	4. 元祖（tuple）
  >	5. 字符串（string）
  
- 访问修饰符
  Python 类中的所有成员都是公有的（public），可以在类外访问并进行修改
  >	1. 私有的（private）：_testVar(单下划线)
  >	2. 受保护的（protected）：__testVar(双下划线)
  
- 定义相关
	>	1. class
	>	2. def
	>	3. lambda

- 控制流
>	1. if...elif...else...：条件判断
>	2. for...in：对可迭代对象循环遍历
>	3. for...in...else...：遍历正常完成则执行 else 后的代码
>	4. continue：终止本次循环，继续下一次循环
>	5. break：跳出循环
>	6. while：循环结构

- 常见关键字
	- 逻辑判断
	>	1. and
	>	2. or
	>	3. not
	>	4. in
	>	5. not in
	>	6. is：比较两个变量的内存地址
	- 异常
	>	try:
	>		代码 1
	>	except：
	>		代码 2
	>	else：
	>		代码 3：
	>	finally：
	>		代码 4
	>	1. 代码 1 发生异常就执行 代码 2，正常就执行 代码 3，无论正常与否都要执行代码 4
	>	2. raise：主动触发异常

- 命令空间
	- global：将模块空间变量引入到局部空间修改
	- nonlocal：将本局部空间的外层空间变量引入到本层局部空间修改，用来嵌套函数内

- 其他：
	- yield：生成器关键字
	- del：从上下文堆栈中删除某个对象

>问：list、tuple、dict、set 用法和区别是什么？
>答：list列表（[]）、tuple元组（()）、dict字典（{}）、set 集合（{}）
>	1. list：a_list = [1, True, 'c']，有序，读写，元素可修改，可下标访问
>	2. tuple：跟列表相似，不同之处就是元组的元素不可修改，a_tuple = (1, True, ‘aa’)，有序，只读，元素不可修改，可下标访问
>	3. dict：a_dict = {‘name’: ‘xuan’, ‘age’: 21}，无序，读写，元素可修改，可下标访问
>	4. set：a_set = {1, True, ‘aa’}    s = set( [1, True, ‘aa’])，无序，读写，元素不可修改，不可下标访问

- 常见操作方法
	- list（列表）
	>	1. append：末尾追加元素，append("dsb")
	>	2. insert：指定位置插入元素，未指定则末尾追加，insert(10, "dsb")
	>	3. a.extend(b)：将 b 的元素追加在 a 上
	>	4. count("dsb")：查看 dsb 在列表中的个数，不存在返回 0
	>	5. index("dsb")：查看元素 dsb 的下标，如有多个则返回第一个，不存在则会报错
	>	6. pop()：删除列表最后一个元素
	>	7. pop(6)：删除列表第7个元素，越界则报错
	>	8. remove()：删除 list 里面的元素
	- dict（字典）
	>	1. get("dsb")：通过 dsb 获取值，如果没有对应的值则返回 None
	>	2. keys()：获取所有的 key 值
	>	3. values()：获取所有的 values 值
	>	4. for k, v in d.items():
	>	    print(k, v)
	>	    遍历字典
	>	5. pop("dsb")：删除字典中对应 dsb 及其对应的 value 
	>	6. popitem()：删除字典最后一个 key 及其对应的 value
	>	7. del d['key']：删除字典
	>	8. clear()：清空字典
	- os
	>	1. os.remove()：删除文件
	>	2. os.rename()：重命名文件
	>	3. os.walk()：生成目录树下的所有文件
	>	4. os.chdir()：改变目录
	>	5. os.mkdir/makedirs：创建目录/多层目录
	>	6. os.listdir()：列出指定目录的文件
	>	7. os.getcwd()：获取当前工作目录
	>	8. os.chmod()：改变目录权限
	>	9. os.path.basename()：去掉目录路径，返回文件名
	>	10. os.path.dirname()：去掉文件名，返回目录路径
	>	11. os.path.join()：将分离的各部分组合成一个路径名
	>	12. os.path.getsize()：返回文件大小
	>	13. os.path.exists()：是否存在
	>	14. os.path.isads()：是否为绝对路径
	>	15. os.path.isdir()：是否为目录
	>	16. os.path.isfile()：是否为文件

- 常见的内置方法
	- 数学运算
	>	1. abs：对绝对值求和
	>	   abs(-2) --> 2
	>	2. divmod：返回两个数的商和余数
	>	   divmod(6, 4) --> (1, 2)
	>	3. max：返回可迭代对象中的元素中的最大值或者所有参数的最大值
	>	  3.1 max(1, 2, 3) --> 3
	>	  3.2 max('123456') --> '6'
	>	  # 传入了 key=abs 函数，会把所有的参数都进行绝对值求和再取最大值
	>	  3.3 max(-1, 0, key=abs) --> -1 
	>	4. min：与 max 相反
	>	5. pow：返回两个数值的幂运算值或其与指定整数的模值
	>	   pow(2, 3) --> 8
	>	   pow(2, 3, 5) --> 3
	>	   pow(2, 3) % 5 --> 3
	>	6. round：对浮点数进行四舍五入求值
	>	   round(1.23451, 1) --> 1.2
	>	7. sum：对元素类型是数值的可迭代对象求和
	>	   sum([1, 2, 3]) --> 6
	
	- 类型转换
	>	1. tuple：根据传入的参数创建一个新的元祖
	>	   # 不传参，创建空元祖
	>	   tuple() --> () 
	>	   # 传入可迭代对象，创建新元祖
	>	   tuple("12345") --> ('1', '2', '3', '4', '5') 
	>	2. lsit：根据传入的参数创建一个新的列表
	>	   # 不传入参数，创建空列表
	>	   list() --> []
	>	   # 传入可迭代对象，使用其元素创建新的列表
	>	   list("qwert") --> ['q', 'w', 'e', 'r', 't']
	>	3. dict：根据传入的参数创建一个新的字典
	>	   # 不传任何参数，返回空字典
	>	   dict() --> {}
	>	   # 可传入键值对创建字典
	>	   dict(a=1, b=2, c=3) --> {'a' : 1, 'b' : 2, 'c' : 3}
	>	   # 可传入映射函数创建字典
	>	   dict(zip(['a', 'b', 'c'], [1, 2, 3])) --> {'a' : 1, 'b' : 2, 'c' : 3}
	>	   # 可传入可迭代对象创建字典
	>	   dict((('a', 1), ('b', 2), ('c', 3))) --> {'a': 1, 'b': 2, 'c': 3}
	>	4. set：根据传入的参数创建一个新的集合
	>	   # 不传入参数，创建空集合
	>	   set() --> set()
	>	   # 传入可迭代对象，创建集合
	>	   a = set(range(10)) -- > {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
	>	5. frozenset：根据传入的参数创建一个新的不可变集合
	>	   a = frozenset(range(5)) --> frozenset({0, 1, 2, 3, 4})
	>	6. enumerate：根据可迭代对象创建枚举对象
	>	   seasons = ['python', 'golang', 'java']
	>	   list(enumerate(seasons))
	>	   --> [(0, 'python'), (1, 'golang'), (2, 'java')]
	>	7. range：根据传入的参数创建一个新的range 对象
	>	   a = range(10)
	>	   b = range(1, 10)
	>	   c = range(1, 10, 3)
	>	   # 分别输出 a,b,c
	>	   (range(0, 10), range(1, 10), range(1, 10, 3)) -->  (range(0, 10), range(1, 10), range(1, 10, 3))
	>	   # 分别输出 a，b，c 的元素
	>	   list(a), list(b), list(c)
	>	   --> ([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [1, 2, 3, 4, 5, 6, 7, 8, 9], [1, 4, 7])
	>	8. iter：根据传入的参数创建一个新的可迭代对象
	>	   a  = iter("qwer")
	>	   next(a) --> 'q'
	>	   next(a) --> 'w'
	>	   next(a) --> 'e'
	>	   next(a) --> 'r'
	>	   next(a)
	>	 `Traceback (most recent call last): File "<stdin>", line 1, in <module> StopIteration`
	>	9. super：根据传入的参数创建一个新的子类和父类关系的代理对象（继承、多态常有）
	
	- 序列操作
	>	1. all：判断可迭代对象的每个元素是否都为 true
	>	   all((1, 2, 3)) --> True
	>	   all(([1, 2], [3, 4]) --> True
	>	   all({(1, 2), (3, 4)}) --> True
	>	   all([0]) --> False # 0 是 false
	>	2. any：判断可迭代对象的元素是否有为 true 值的元素
	>	   any([0, 1, 2]) --> True # 列表中有一个 true 则返回 true
	>	   any([0, 0]) --> False # 全为 false 则返回 false
	>	   # 空列表、空字典返回 false
	>	   any([])、any({}) --> False
	>	3. filter：使用指定方法过滤可迭代对象的元素
	>	   a = list(range(1, 10)) --> [1, 2, 3, 4, 5, 6, 7, 8, 9]
	>	   # 定义奇数判断函数
	>	   def if_odd(x):
	>	       return x%2 == 1
	>	   # 筛选序列中的奇数
	>	   list(filter(if_odd, a) --> [1, 3, 5, 7, 9]
	>	4. map：使用指定的方法区作用传入的每个可迭代对象的元素，生成新的可迭代对象
	>	   a = map(ord, 'abc')
	>	   list(a) --> [97, 98, 99]
	>	5. next：返回可迭代对象中的下一个元素值，若元素取完则会返回StopIteration异常
	>	   a = iter('qwer')
	>	   next(a) --> 'q'
	>	   next(a) --> 'w'
	>	   # 建议传入 default 参数，若取完则不会返回StopIteration错误，返回默认的值
	>	   next(a, 'e') --> 'e'
	>	6. reversed：反转序列生成新的可迭代对象
	>	   a = reversed(range(10)) # 传入range 对象
	>	   a 的类型变成了迭代器
	>	   list(a) --> [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]
	>	   这里遇到过面试题就是如果讲一个字符串（列表、元祖）取反，用[::-1]可以完成，reversed 也可以达到相同的效果
	>	7. sorted：对可迭代对象进行排序，返回一个新的列表
	>	   a = (1, 3, 1, 4) --> [1, 1, 3, 4] # 默认根据 ASCII 码排序
	>	   a = a = ('A', 'b', 'c', 'B')
	>	   sorted(a, key=str.upper) --> ['A', 'b', 'B', 'c']
	>	8. zip：聚合传入的每个迭代器中相同位置的元素，返回一个新的元祖类型迭代器
	>	   a = [1, 2, 3] # 长度 3
	>	   b = [4, 5, 6, 7, 8] # 长度 5
	>	   list(zip(a, b)) --> [(1, 4), (2, 5), (3, 6)] # 取最小长度 3
	- 反射操作
	>	1. __import__：动态导入模块
	>	   index = __inport__('index')
	>	   index.Fuck()
	>	2. isinstance：判断对象是否非类或者类型元祖中的任意类元素的实例
	>	   isinstance(1, int) --> True
	>	   isinstance(1, str) --> False
	>	   isinstance(1, (int, str)) --> True
	>	3. issubclass：判断类是否是另一个类或者类型元祖中任意类元素的子类
	>	   issubclass(bool, int) -->True
	>	   issubclass(bool, str) --> False
	>	   issubclass(bool, (int, str)) --> True
	>	4. hasattr：检查对象是否含有属性
	>	   # 定义类
	>	   class Dog:
	>		   def __init__(self, name):
	>			   self.name = name
	>	  d = Dog("旺财")
	>	  hasattr(d, 'name') --> True
	>	  hasattr(d, 'age') --> False
	>	5. getattr：获取对象的属性值
	>	   class Student:
	>	       def __init__(self, name):
	>	           self.name = name
	>	 s = Student("gilbert")
	>	 getattr(s, 'name') --> 'gilbert'
	>	 getattr(s, 'aget') --> 不存在则报错
	>	6. setattr：设置对象的属性值
	>	   class Student:
	>	       def __init__(slef, name):
	>	           self.name = name
	>	  s = Student('gilbert')
	>	  a.name = 'gilbert'
	>	  setattr(s, 'replaceName')
	>	  a.name = 'replaceName'
	>	7. delattr：删除对象的属性
	>	   class User:
	>	       def __init__(self, name):
	>	           self.name = name
	>	       def juan(self):
	>	           print(self.name, '贼能卷')
	>	  u = User('波波')
	>	  delattr(u, 'name') --> 删除对象 u 的 name 属性，继续访问 u.name就会报错
	>	8. callable：检查对象是否可被调用
	>	   class Student:
	>	       def __init__(self):
	>	           print('instances are callable now.')
	>	           
	>	  # 类 student 是可调用对象
	>	  callable(Studen) --> True 
	>	  # 调用类 Student
	>	  s = Student() 
	>	  # 实例 s 是可调用对象
	>	  callable(s) --> True 
	>	  # 调用实例 b 成功
	>	  b() --> instances are callable now.
	- 变量操作
	>	1. globals：返回当前作用域内的全部变量和其值组成的字典
	>	   "{'__name__': '__main__', '__doc__': None, '__package__': None, '__loader__': <class '_frozen_importlib.BuiltinImporter'>, '__spec__': None, '__annotations__': {}, '__builtins__': <module 'builtins' (built-in)>}"
	>	2.locals：返回当前作用域内的局部变量和其值组成的字典
	>	def test():
	>		print('before define a')
	>		print(locals())
	>		a = 1
	>		print('after define a')
	>		print(locals())
	>	test() --> before define a /n {}  /n after define a  /n {'a': 1}
	- 交互操作
	>	1. print
	>	2. input
	- 文件操作
	>	1. open：使用指定的模式和编码打开文件，返回文件读写对象
	>	   # t 为文本读写，b 为二进制读写
	>	   f = open(./contest.py, 'rt')
	>	   a.read()
	>	   a.close()
	- 装饰器
	>	1. property：表示属性的装饰器
	>	   class A:
	>	       def __init__(self):
	>	           self.name = ''
	>	       @property
	>	       def name(self):
	>	           """i'm the 'name' property."""
	>	           return self._name
	>	       @name.setter
	>	       def name(self, value):
	>	           if value is None:
	>	               raise RuntimeError('name can't be None)
	>	           else:
	>	               self._name = value
	>	  a = A()
	>	  a.name --> ''
	>	  # 设置属性时进行验证
	>	  a.name = None --> 返回定义的异常信息
	>	  # 设置属性和访问属性
	>	  a.name = 'gilbert'
	>	  a.name  --> 'gilbert'
	>	2. classMethod：标识为类方法的装饰器
	>	   class Student:
	>	       def __init__(self, name):
	>	           self.name = name
	>	       @staticmethod
	>	       def sayHi(lang):
	>	           print(lang)
	>	           if lang == 'en':
	>	               print('welcome!')
	>	           else:
	>	           print('雷好！')
	>	   
	>	   # 直接通过类调用类方法
	>	  Student.sayHi('en')  --> welcome!
	>	3. staticMethod：标识为静态方法的装饰器
	>	   class Student：
	>	       def __init__(self, name):
	>	           self.name = name
	>	       @staticmethod
	>	       def sayHi(lang):
	>	           print(lang)
	>	           if lang == 'en':
	>	               print('welcome!')
	>	           else:
	>	               print('雷好！')

**常用函数**
可能面试中会问到你常用的函数有哪些
>	1. print()函数：打印字符串
>	2. raw_input()函数：从用户键盘捕获字符
>	3. len()函数：计算字符长度
>	4. format(12.3654，'6.2f'/'0.3%')函数：实现格式化输出
>	5. type()函数：查询对象的类型
>	6. int()函数、float()函数、str()函数等：类型的转化函数
>	7. id()函数：获取对象的内存地址
>	8. help()函数：Python的帮助函数
>	9. s.islower()函数：判断字符小写
>	10. s.sppace()函数：判断是否为空格
>	11. str.replace()函数：替换字符
>	12. import()函数：引进库
>	13. math.sin()函数：sin()函数
>	14. math.pow()函数：计算次方函数
>	15. os.getcwd()函数：获取当前工作目录
>	16. listdir()函数：显示当前目录下的文件
>	17. open().write()函数：写入文件
>	18. time.sleep()函数：停止一段时间
>	19. random.randint()函数：产生随机数
>	20. range()函数：返回一个列表，打印从1到100
>	21. file.readlines()函数：读取文件返回列表
>	22. file.readline()函数：读取一行文件并返回字符串
>	23. find(s[start,end])函数：从字符串中查找s
>	24. strip()、lstrip()、rstrip()函数：去除空格
>	25. lower()函数：将数据改成小写
>	26. upper()函数：将数据改成大写
>	27. startswith(s)函数：判断字符串是否以s开始的
>	28. endwith(s)函数：判断字符串是否以s结尾的
>	29. file.write()函数：写入函数
>	30. file.writeline()函数：写入文件
>	31. s.append()函数：在数据的尾部插入数据
>	32. s.insert(3,-1)函数：在3的位置之前插入数据-1
>	33. list()函数：将字符串转换成列表
>	34. index(value)函数：在数据中查找第一次value的位置
>	35. count()函数：统计数据中的某个元素的出现次数
>	36. list.remove(“s”)函数：将数据中第一次出现的s删掉
>	37. del list[2]函数：将数据的第2个元素删掉
>	38. pop()函数：去掉数据的指定位置的数据，有返回值
>	39. remove(“ha”)函数：去掉原数据中的“ha”元素
>	40. reverse()函数：列表的逆序
>	41. isinstance()函数：判断某个数据是否为某种类型
>	42. abs()函数：得到某数的绝对值
>	43. find()函数：查找 返回的是索引
>	44. join()函数：split的逆操作
>	45. clear()函数：清楚字典中的所有项
>	46. copy()函数：复制一个字典，会修改所有的字典
>	47. d.copy()函数：复制一个字典，只会修改当前字典
>	48. get()函数：查询字典中的元素
>	49. items()函数：将所有的字典返回一个列表
****
### Java 基础
****
### 网络相关
****
### 性能测试
通过测试工具（jmeter 等）模拟多重正常、峰值以及异常负载条件来对系统的各项性能指标进行测试。[负载测试](https://baike.baidu.com/item/%E8%B4%9F%E8%BD%BD%E6%B5%8B%E8%AF%95/10921210?fromModule=lemma_inlink)和[压力测试](https://baike.baidu.com/item/%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95/10029152?fromModule=lemma_inlink)都属于性能测试，两者可以结合进行。通过[负载测试](https://baike.baidu.com/item/%E8%B4%9F%E8%BD%BD%E6%B5%8B%E8%AF%95/10921210?fromModule=lemma_inlink)，确定在各种工作负载下系统的性能，目标是测试当负载逐渐增加时，系统各项性能指标的变化情况。[压力测试](https://baike.baidu.com/item/%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95/10029152?fromModule=lemma_inlink)是通过确定一个系统的瓶颈或者不能接受的性能点，来获得系统能提供的最大服务级别的测试。

**压测类型**
- 压力测试(Stress Testing)：
  >	也称之为强度测试，测试一个系统的最大抗压能力，在强负载(大数据、高并发)的情况下，测试系统所能承受的最大压力，预估系统的瓶颈
- 并发测试(Concurrency Testing)：
  >	通过模拟很多用户同一时刻访问系统或对系统某一个功能进行操作，来测试系统的性能，从中发现问题(并发读写、线程控制、资源争抢)
- 耐久性测试(Configuration Testing)：
  >	通过对系统在大负荷的条件下长时间运行，测试系统、机器的长时间运行下的状况,从中发现问题(内存泄漏、数据库连接池不释放、资源不回收)
  
**性能测试流程**
首先是需要熟悉被测系统的业务逻辑，其次是需要了解到项目架构，方便更好的确定测试方案和问题分析
1. 时机
   >1. 确保什么时候做性能测试，包括但不限于接口响应变慢、用户反馈页面加载时间过长等
   >2. 压测指标确定（1.有需求方提出 2.根据业务实际的数据增加 20%左右）
2. 方案
   >1. 出现以上问题评估是否需要进行压测（优先调整业务查询的慢sql等开发代码层的问题）
   >2. 准备压测方案和压测的脚本，然后发起评审
   >3. 申请测试环境
3. 实践
   >1. 如有单独环境有时间就可以进行压测，如果没有只能等到业务低谷时间段来进行压测
   >2. 查看日志和监控，保留压测报告
4. 总结
   >1. 编写性能测试报告，给出测试结论（1.满足需求可以上线 2.部分接口未满足要求）
   >2. 针对未满足要求的情况可以指定对应的方案，比如增加硬件配置（简单粗暴）、SQL 优化等

**常见的性能指标**
- 硬件
  >1. cpu
  >2. 内存
  >3. 磁盘
- 软件
  >1. sql 耗时
  >2. 吞吐量
  >>	2.1 QPS：每秒查询次数
  >>	2.2 TPS：每秒事务次数
  >3. 命中率
  >4. 锁
  >>	4.1 等待次数：锁的等待次数
  >>	4.2 等待时间：锁的等待时间

>问：性能测试你一般关注哪些指标？
>答：一般关注以下指标
>>	1. RT(response time)：响应时间，一般取平均值，不同行业的可接受时间不同，一般互联网行业 500 毫秒以内
>>	2. TPS（Transaction per Second）：系统每秒处理事务数，单位是次/秒
>>	3. QPS（Query per Second）：系统每秒处理查询次数，单位是次/秒。
>>	4. HPS（Hits Per Second） ：每秒点击次数，单位是次/秒
>>	5. 错误率：指系统在负载情况下，失败交易的概率。错误率＝（失败交易数/交易总数）×100%
>>	   稳定性较好的系统，其错误率应该由超时引起，即为超时率
>>	6. CPU：中央处理器是一块超大规模的集成电路，是一台计算机的运算核心和控制核心
>>	7. 内存：内存是计算机中重要的部件之一，它是与CPU进行沟通的桥梁
>>	8. 磁盘吞吐量：磁盘吞吐量是指在无磁盘故障的情况下单位时间内通过磁盘的数据量

**性能测试方案**
性能测试方案说的通俗一点就是指导我们进行性能测试的文档，包含测试目的、测试方法、测试场景、环境配置、测试排期、测试资源、风险分析等内容
**测试方案内容**
- 制定性能测试目的
  >	测试目的是我们首先要考虑的内容。是要完成既定的指标还是验证超卖问题，抑或是验证并发下的稳定性问题
- 性能测试场景梳理
  >	1. 基准测试
  >	   单线程或少量线程对单接口进行测试。作用是验证测试脚本及测试数据的正确性，同时也可以验证脚本数据是否支持重复性测试。
  >	2. 单接口负载场景
  >	   通过模拟多线程对单接口进行负载测试。具体做法就是选定线程数后阶梯式运行一段时间，比如分别是 100 线程、200 线程、300 线程各持续 5 分钟，然后获取事务响应时间、TPS、错误率等数据，监测被测系统的各服务器资源使用情况（CPU、内存、磁盘、网络等），获取 TPS 拐点
   ![](https://s2.loli.net/2023/03/22/prq2SFXR9mLlhBy.png)
  >	3. 混合场景负载测试
  >	   这个场景是性能测试中最重要的场景之一，是为了最大程度模拟用户真实的操作。真实的线上操作不只有单接口的操作，一定是多种业务同时在进行，比如张三在浏览商品，李四在添加购物车等
  >	   如何使用 JMeter 控制场景比例：JMeter 提供了一个能较好地解决这个问题的插件，叫作**吞吐量控制器**，它在逻辑控制器组件中
  >	4. 异常性能测试
  >	   在系统异常的情况下看系统的处理能力或者是通过处理后的恢复能力是如何的
  >	   比如在架构高可用方面，会遇到服务的上下线、数据库的主从切换等这些情况的时延是多少、处理能力能不能达到预期标准。
  >	   在电商应用架构中，大促遇到紧急情况经常需要限流和熔断，前者就是控制单位时间内的请求量，比如城市的早晚高峰车辆限行，这也是一种限流方式。而后者就比较直接了，当判断到调用的依赖服务报错到达一定数量后，直接返回一个既定的数据，将不再访问该服务，类似家中的保险丝，打到阈值之后就会自动跳闸断电，以保障电路安全。所以我们也会测试触发限流和熔断所设置的阈值，并观察触发后的系统表现是如何的
  >	5. 稳定性性能测试
  >	   通过给系统加载一定压力的情况下，运行一段较长的时间，来验证系统是否稳定
>>	常见问题
>>	1.问：什么情况下可以停止负载测试？
>>	答：我们做性能测试无论是单接口负载测试还是混合场景的负载测试都是梯度增加线程数，那线程数增加的具体阈值如何确定呢？
>>	情况一：理想状态下的测试过程，根据上图我们就可以得知随着线程数的增加 TPS 也会发生变化，找到 TPS 的峰值便是我们需要的具体阈值了，如果符合预期，那么我们就可以停止负载测试了
>>	情况二：可能系统没有到达峰值，接口就已经报错了，针对这种情况我们一般会协商确定异常场景下的停止条件，比如 CPU 达到了 70%、RT 超过了 1000ms、错误率达到 2%等，当触发到这些条件时，我将不会继续家线程进行测试了
>>	
>>	2.问：单接口梯度测试完成后，混合场景选取那个线程梯度的访问量进行测试？
>>	答：一般会基于峰值处理能力去进行稳定性测试，但实际情况还是要根据具体的业务数据量确定
- 确定被测业务的部署架构
  >	1. 简单来说就是被测项目涉及那些组件，每个组件部署在哪些服务器上，服务器的配置是怎么样的。可以画一个简单的架构示意图
  >	如下图所示：
  >![](https://s2.loli.net/2023/03/23/WqPVulfOX8YHvQ9.png)
>	这是一个比较经典的链路，从客户端发起到服务端，服务端从代理层到应用层，最后到数据层。
  - qwe
  - qwe
****
### 系统架构
****
### 简单算法题
****
>问：给定一个字符串（如hello），返回出现次数最多的字符以及次数？

>答：简单说一下思路，定义一个接收string类型的函数，创建一个空的字典，使用字典存储传进来的字符串，在循环中判断s是否存在字典中，如果存在就给对应的键值+1，不存在就赋值=1.最后使用max()函数获取键值最大的字符。
>>	class InterView:
>>		def sumOfChars(self, str: string):
>>			str_dict = {}
>>			// 判断一下特殊场景（空字符串）
>>			if len(str) == 0:
>>				print("请输入长度大于0的字符串")
>>				return
>>			// 其中，我们使用字典存储每个字母出现的次数，并在循环中对每个字母进行计数
>>			for s in str:
>>				if s in str_dict:
>>					str_dict[s] += 1
>>				 else:
>>					 str_dict[s] = 1
>>				 // 实时输出对应的字典
>>				 print(f'{str_dict}')
>>			 // 最后使用 max() 函数取出字典中键值最大的字母，即出现次数最多的字母
>>			 most_str = max(str_dict)
>>			 // 输出最大的字符以及出现的次数
>>			 print(f'最大值是：{most_str}, 出现了{str_dict[most_str]}次')
运行结果：
![](https://s2.loli.net/2023/02/09/mtlX3rH1RuW8kZ6.png)

>问：给定一个整数数组 nums和一个整数目标值 target，请你在该数组中找出和为目标值 target  的那 两个 整数，并返回它们的数组下标？（两数之和）
>答：
>>	twoSum.py
>>	class Solution:
>>		def twoSum(self, nums: List[int], target: int) -> List[int]:
>>			n = len(nums)
>>				for i in range(n):
>>					for j in range(i+1, n):
>>						if nums[i] + nums[j] == target:
>>							return [i, j]
>>				return []
>
>>	twoSum.go
>>	func twoSum(nums []int, target int) []int {
>>		n := len(nums)
>>		for i, v := range nums {
>>			for j := i + 1; j < n; j++ {
>>				if v+nums[j] == target {
>>					return []int{i, j}
>>				}
>>			}
>>		}
>>	return nil
>>	}

>问：知道冒泡排序吗，使用你熟悉的语言实现一下
>答：基本的排序思路是从头开始两两元素进行比较，大的元素就往上冒，这样遍历一轮后，最大的元素就会直接筛选出来。然后再重复上述操作，即可完成第二大元素的冒泡。以此类推，直到所有的元素排序完成
>>	bubbleSort.py
>>	class Solution:
>>		def bubble_sort(self, nums: List[int]):
>>			n = len(nums)
>>			for i in range(n):
>>				for j in range(n - i - 1):
>>					if nums[j] > nums[j+1]:
>>						nums[j], nums[j+1] = nums[j+1], nums[j]
>
>>	bubbleSort.go
>>	func bubble_sort(nums []int) []int {
>>		n := len(nums)
>>		for i := 0; i < n; i++ {
>>			for j := 0; j < n-i-1; j++ {
>>				if nums[j] > nums[j+1] {
>>				// 交换(>用于控制排序规则)
>>					nums[j], nums[j+1] = nums[j+1], nums[j]
>>				}
>>			}
>>		}
>>		return nums
>>	}