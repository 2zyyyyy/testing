### 自我介绍
>问：请简单做一下自我介绍吧

建议将自我介绍的时长控制在60～90s左右，主要介绍一下自己的个人背景+工作背景+亮点
>答：面试官你好，我叫张三，2016年毕业于某学校的某专业（拿不出就不需要提，比如非本科或者非计算机相关的专业），从2016年毕业从事软件测试行业至今已有6年多的工作经验，先后在a公司和b公司（时间段+行业）任职，主要负责业务的功能测试（web、app、h5）、服务端测试和接口自动化测试，把控项目进度和质量直至发布上线。个人比较擅长xxx测试（api自动化、ui自动化、专项测试、性能测试都可以）
****
### 测试理论相关

**测试用例**
>问：测试用例设计的方法有哪些，你一般工作中会用到哪些测试用例的设计方法？

用例设计其实是分为功能测试用例和单元测试用例设计的（黑盒和白盒），如果问题中没有确定是针对哪一个场景的，建议都回答上
>答：测试用例设计分为功能测试用例和单元测试用例设计，功能测试用例设计常用的方法有等价类、边界值分析、因果图、正交试验设计、功能图分析、错误推断、需求文档转换、随机测试、对象属性分析。单元测试的用例设计有语句覆盖、判定覆盖、条件覆盖、判定条件覆盖、条件组合覆盖、路径覆盖。
>功能中主要以黑盒测试为主，所以用到的就是功能测试用例设计的方法，一般常用的都是等价类分析（有效等价类、无效等价类）、边界值分析、错误推测、随机测试等

>场景：登录页面的测试用例设计？

针对该问题首先需要考虑的是功能层面的问题，其次还要考虑安全、兼容性、性能、用户体验等方面的测试用例

>功能层面：
>1.输入已注册的用户名和正确的密码，验证是否登录成功
>2.输入已注册的用户名和错误的密码，验证是否登录失败
>3.输入未注册的用户名和任意的密码，验证是否登录失败
>4.不输入用户名和密码，验证是否登录失败
>5.用户名或密码不输入，验证是否登录失败
>6.如果有验证码，在用户名和密码都正确的情况下，输入正确的验证码，验证是否登录成功
>7.如果有验证码，在用户名和密码都正确的情况下，输入错误的验证码，验证是否登录失败
>8.用户名密码针对大小写是否敏感
>9.密码是否加密展示
>10.系统创建的用户首次登录是否提示修改密码
>11.忘记密码功能是否可用
>12.前端是否根据需求限制用户名和密码的长度
>13.如果需要验证码，点击验证码是否可以更换验证码，更换后的验证码是否可以正常使用登录
>14.刷新页面是否会刷新验证码
>15.如果是具有实效性的短信验证码，验证在时效内和失效外验证码的有效性
>16.会话超时操作是否回返回到登录页面
>17.不同角色的账户登录是否返回不同的角色菜单
>18.访问页面时默认的焦点是否在用户名输入框
>19.针对用户名、密码、验证码输入框是否可以正常使用快捷键tab、enter
>20.鼠标光标的状态展示，只有在固定的位置才显示可点击或编辑状态
>21.如果账号设置了单点登录，验证同一个账号在多个浏览器或电脑登录是否会将原有的回话置为过期
>安全层面：
>1.如果是短信验证码，当天是否有接收限制（防刷）
>2.用户密码及个人信息是否加密存储
>3.前后端交互（请求接口）针对敏感信息是否加密（密码、手机号码等）
>4.后端是否会返回用户数据的敏感信息（创建时间、用户id等等）
>5.未登录的情况下，访问登录后的路由是否会重定向到登录页
>6.密码输入框知否不支持复制粘贴
>7.密码输入框的密码是否无法在开发者工具下查看
>8.连续多次的密码错误是否会有保护机制（防止暴力破解）
>9.登录接口返回的数据是否对用户信息进行加密显示
>10.登录ua获取，确保是用户本人登录
>性能层面：
>1.单用户登录的响应时长是否小于2秒
>2.单用户登录时，后台请求数量是否过多
>3.高并发场景下用户登录的响应时间是否小于5秒
>4.高并发的场景下，服务监控的各项指标是否正常（响应时长、数据库、服务器资源）
>5.防止同一用户恶意并发
>兼容层面：
>1.不同类型的浏览器下，验证登录页面的显示以及功能的正确性
>2.统一浏览器的不同版本（高低）下，验证登录牙面的显示以及功能的正确性
>3.不同移动终端设备的不同浏览器下，验证登录页面的显示以及功能的正确性
>4.不同分辨率的界面下，验证登录页面的显示以及功能的正确性
>其他：
>1.针对不同场景下的登录失败，验证对应的错误信息展示（前端根据后端接口返回的错误信息回显给用户，未调用服务端接口的错误由前端处理）

>问：测试用例包含哪些内容（测试用例的格式）

>答：一条完整的测试用例应该包含用例编号、用例标题、前置条件、操作步骤、测试数据、预期结果、优先级等字段
****
#### 测试流程
>问：你们公司的测试流程是怎么样的？

>答：熟悉需求文档、参与需求评审和技术评审、测试分析（1⃣️根据需求提取功能点，确定测试范围2⃣️对独立功能进行分析，确定各独立功能的测试点3⃣️对功能组合进行分析，提供业务场景的测试点4⃣️分析分功能特性，了解测试对象的非功能特性）、测试用例设计、组织测试用例评审、提测之后的冒烟测试、冒烟通过后执行测试用例、缺陷的提交与回归测试、系统集成测试、通知产品/设计验收、发布生产环境、出具测试报告、项目复盘（如有需要）
>****
#### 测试文档
>测试过程中会产生哪些文档？

>答：不同的测试阶段会产生其对应的文档。分析-测试计划、测试方案，设计-测试计划、测试方案，执行-冒烟测试报告、测试报告，总结-复盘报告

>问：测试计划包含哪些内容？

>答：项目背景、资源分配、测试通过和失败标准、测试暂停、挂起、恢复原则、测试人力资源计划表、测试产出、会议评审记录。
>>拓展问题，做好测试计划的关键点？
>>目的、管理、规范

>问：测试方案包含了哪些内容？

>答：项目背景、测试环境、测试软硬件资源、测试策略、测试风险分析、测试范围、测试用例设计、测试报告

**缺陷相关**
>问：一个缺陷包含哪些内容？

>答：一个完整的缺陷应该包含标题、问题描述或总结、前置条件、测试数据、测试步骤、测试结果（期望结果和实际结果）、缺陷等级、缺陷优先级、项目信息（归属项目、版本号、模块）、缺陷分类、责任人、附件（如有）
>****

### 项目介绍
一般会让你简单介绍一下简历中所写的项目。以下总结了一些面试官常用的提问方式：
| 方式                                                                                                 | 目的                                                                 |
| ---------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------- |
| 让你描述工作经验和项目（最近或最熟悉的），看看你说的是否和简历上一致                               | 看你是否真的做过这些项目|
| 看你简历上项目里用到的技术，比如框架、数据库，然后针对这些技术提些基本问题                           | 还是验证你是否做过项目，同时看你是否了解这些技术，为进一步提问做准备 |
| 针对某个项目，不断深入地问一些业务上的问题，或者从不同侧面问一些技术实现，看你前后回答里面是否有矛盾 | 深入核实你的项目细节|
| 针对某技术，问些项目里一定会遇到的问题，比如候选人说做过数据库，那么就会问索引方面的问题|通过这类问题，核实候选人是否真的有过项目经验|
****
### mysql相关
**理论相关**
个人感觉不太会问到，大概了解一下即可。
- DML（data manipulation language）：它们是select、update、insert、delete，是用来对数据库里的数据进行操作的语言
- DDL（data definition language）：常用的 create、alter、drop 等，主要用在定义或改变表的结构、数据类型、表之间的链接和约束等初始化工作上，大多在表建立的时候使用
- DCL（Data Control Language）：数据库控制功能。是用来设置或更改数据库用户或角色权限的语句，包括（grant,deny,revoke等）语句
****
**DDL相关问题**
不以问答形式展示了，直接总结一些常用的吧（表名称我们就用最常见的user表）
>1.创建数据库：create database user;
>2.查看数据库列表：show database;
>3.删除数据库：drop user;
>4.查看表设计：1⃣️desc user; 2⃣️show create table user;
>5.清空表：1⃣️truncate table user; 2⃣️delete from user;
>6.删除字段：alert table user drop username;
>7.新增字段：alert table user add username varchar;
>8.修改字段类型：alert table user modify username int;
>9.修改字段：alert table user change username name varchar;
>10.创建索引：alert table user index 索引名(字段1,字段2);
>11.创建主键索引：alert table user add primary 索引名(字段1,字段2);
>12.查看索引信息：show index from user;
>13.删除索引：alert table user drop index 索引名;

**** 
**DML相关**
>常用查询
>	1.查询结果去重：
>	`select distinct 字段名 from 表名`;
>	2.取5～10条数据：
>	`select * from user limit 5 offset 10;`
>	3.根据年龄倒序：
>	`select * from user order by age desc;`
	4.数据过滤(or、and、in、not in、between…and)
>>4.1 查询年龄为20或体重120且分数大于80的用户信息：
>>`select * from user where score >90 and (age=20 or weight=120);`
>>4.2 查询分数为60、80、90的用户：
>>`select * from user where score in (60,80,90);`
>>4.3 查询年龄在6～12岁之间的用户：
>>`select * from user where age between 6 and 12; `
	5.模糊匹配(like)
>>5.1 姓张的用户：
>>`select * from user where name like '张%';`
>>5.2 名字以杰结尾的用户：
>>` select * from user where name like '%杰';`
>>5.3 名字包含流的用户：
>>`select * from user where name like '%流%';`
>>5.4 表示任意单个字符：
>>`select * from user where name like '张_';`
	6.正则匹配
>>6.1 名字以王开头：
>>`select * from User where name regexp '^王';`
>>6.2 名字以蛋结尾：
>>`select * from User where name regexp '蛋$';`
>>6.3 匹配任意一个字符：
>>`select * from User where name regexp ".万";`
>>6.4 用户名以万、孟开头：
>>`select * from User where name regexp '^[孟,万]';`
	7.内置函数(avg、count、max、min、sum)
>>7.1 查询年龄大于12的用户的平均分：
>>`select avg(score) as “平均分” from user where age > 12;`
>>7.2 返回行数：
>>`select count( * ) from user;`
>>7.3 返回年龄的最大值：
>>`select max(age) from user;`
>>7.4 返回年龄的最小值：
>>`select min(age) from user;`
>>7.5 求和：
>>`select sum(score) from user where score < 60;`
	8.分组(group by、having)
>>8.1 以某个字段分组：
>>`select * from user group by age;`
>>8.2 having过滤分组，查询用户的姓名和平均分，根据用户名分组，且平均分要大于60：
>>`select username, avg(score) as avg_score from user group by username having avg_score > 60;`

	sql语句执行顺序：
	1.from:组装来自不同数据源的数据
	2.where：基于指定的条件对记录进行筛选
	3.group by：子句将数据划分为多个分组
	4.使用聚合函数进行计算
	5.使用having子句筛选分组
	6.计算所有表达式
	7.select的字段
	8.使用order by对结果进行排序
	9.使用limit展示需要的行数
数据库事务的四大特性（简称ACID）：
- 原子性：要么全部完成，要么不完成，若发生错误会进行回滚操作
- 一致性：开始到结束后，数据库完整性约束没受到破坏
- 隔离性：事务与事务之间相隔离，串行化执行
- 持久性：事务完成对数据的影响是永久的

主键与外键：
- 主键：对表中数据进行唯一标识的数据列的组合；不能缺失；不能空值；
- 外键：该列为另一张表的主键

>问：数据库索引是什么，简单说说索引的优缺点？

>答：索引是指数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据
>优点：1⃣️大幅提高系统性能,帮助用户提高查询的速度 2⃣️通过索引的唯一性，可以保证数据库表中的每一行数据的唯一性 3⃣️可以加速表与表之间的链接 4⃣️降低查询中分组和排序的时间
>缺点：1⃣️索引的存储需要占用磁盘空间 2⃣️提高了查询速度，但降低了更新表的速度

>问：mysql有哪些关联查询的种类，分别代表什么意思？

>答：左连接（left join）、右连接（right join）、内连接（inner join）、全连接（full join）
>>左连接：A left (outer) join B, 以 A 表为基础，A 表的全部数据，B 表有的组合，没有的为 null
>>右连接：A right(outer) join B, 以 B 表为基础，B 表的全部数据，A 表有的组合，没有的为 null
>>内连接：两表都满足的组合。内连接分为等值连接，不等连接，自然连接
>>全连接：A full (outer) join 两表相同的组合在一起，A 表有，B 表没有的数据（显示为 null），同样 B 表有，A 表没有的显示为 null

主从备
- 主库
- 从库
- 备库

存储过程

触发器
>问：数据库优化了解过吗，可以从哪些方面入手？

>答：分为软件和硬件两个方面
>软件方面优化：1⃣️分库分表 2⃣️添加索引 3⃣️sql 调优 4⃣️表结构优化 5⃣️读写分离 6⃣️数据库集群
>硬件方便优化：todo

**真题模拟**
![](https://s2.loli.net/2023/02/04/7HxC21oMJmf3AeL.png)
现有表user和department，他们之间用部门id关联
>问：使用单次查询返回每个部门中年龄最大的用户信息，如果年龄一样大则都返回，如图三的结果数据

>	答：思路就是先根据用户和部门关联查询，然后根据部门id分组，但是max聚合函数当age一样的时候只会返回一条数据，需要对年龄一样的的情况做特殊处理，我们就可以先把上面拿到的最大年龄数据当作条件，外面在套一个查询即可。
>	SELECT a.NAME AS "姓名", b.department_name AS "部门", a.age AS "年龄" FROM user2 a LEFT JOIN department b ON a.department = b.department_id WHERE a.age IN ( SELECT max( c.age ) FROM user2 c LEFT JOIN department d ON c.department = d.department_id GROUP BY c.department);
****
### web测试
>问：一个url（统一资源定位符）包含哪些部分？

>答：协议、主机、端口、路径、查询参数、锚点

>问：简述一下浏览器访问一个URL地址的过程？

>答：1⃣️缓存查找 2⃣️dns解析 3⃣️负载均衡和污染 4⃣️建立tcp连接(3次握手) 5⃣️客户端发送http请求 6⃣️服务器处理请求 7⃣️浏览器解析网页 8⃣️客户端关闭tcp连接，4次挥手结束，完成整个访问过程

代理服务器相关
- nginx：是一个高性能的 HTTP 和反向代理服务器，也是一个 IMAP/POP3/SMTP 服务器
- apache：是一个模块化的服务器，源于 NCSAhttpd 服务器
- tomcat：是一个免费的开放源代码的 Web 应用服务器，属于轻量级应用服务器，是开发和调试 JSP 程序的首选

>问：nginx了解吗，有什么优点和哪些应用场景？

>答：nginx是一个高性能的 HTTP 和反向代理服务器。具有跨平台、非阻塞高并发连接、内存消耗小、稳定性高、成本低且开源、内置健康检查功能等优点。
>应用场景有http服务器、虚拟主机等

- 正向代理：代理端代理的是客户端
- 反向代理：代理端代理的是服务端
- nginx限流
	- 限流策略
		- 正常限制访问频率
		- 突发限制访问频率
		- 限制并发连接数
	- 算法
		- 漏桶
		- 令牌桶

- 登录鉴权
	- 认证（Authentication）：通俗地讲就是验证当前用户的身份，证明”你“是你自己
		- 互联网中的认证：
			- 用户名密码登录
			- 邮箱发送登录链接
			- 手机号接收验证码（只要你能收到邮件/验证码，就默认你是当前账号的主人）
	- 授权（Authentication）：在安装应用或者访问小程序时的弹窗询问信息。如在安装手机应用的时候，APP 会询问是否允许授予权限（访问相册、地理位置等权限），在访问微信小程序时，当登录时，小程序会询问是否允许授予权限（获取昵称、头像、地区、性别等个人信息）
		- 实现授权的方式
			- cookie
			- session
			- token
			- oauth
	- 凭证（Credentials）：实现认证和授权的前提是需要一种媒介（证书） 来标记访问者的身份。商鞅住店的照身贴、现代的身份证。在互联网中则体现为一些网站支持游客模式和登录模式，游客模式下，可以正常浏览网站上面的文章，一旦想要点赞/收藏/分享文章，就需要登录或者注册账号。当用户登录成功后，服务器会给该用户使用的浏览器颁发一个令牌（token），这个令牌用来表明你的身份，每次浏览器发送请求时会带上这个令牌，就可以使用游客模式下无法使用的功能。

>问：什么是cookie，有哪些特性？

>答：因为http是无状态的协议，所以需要使用cookie记住每个用户的会话信息。
>cookie存储在客户端且是不可跨域的。

>问：什么是session，使用session认证的流程是什么样的？

>答：session是基于cookie实现的，session存储在服务端，sessionid会被存储在客户端的cookie中，session是另一种记录服务器和客户端会话状态的机制。
>>认证流程：
>>1.用户首次请求服务器时，服务器根据用户信息创建对应session
>>2.请求返回时将该session对应的唯一标识信息sessionid返回给浏览器
>>3.浏览器收到后将sessionid存储到cookie中，同时cookie记录sessionid属于那个域名
>>4.当用户第二次访问时，会自动判断此域名下面是否存在cookie信息，如有就会自动将cookie信息发送给服务端，服务端会从cookie中获取sessionid，在根据id获取session信息。如果没有说明没有登录或登录失败，需要重新走流程

>问：cookie和session有什么区别？

>答：cookie和session有以下几个方面的区别：
>>1.安全性：
>>session比cookie安全，session时存储在服务端的，cookie时存储在客户端
>>2.存取值类型不同：
>>cookie只支持字符串数据，想要设置其他类型的数据需要转换成字符串，session可以存任意数据类型
>>3.有效期不同：
>>cookie可设置长时间保持，session一般失效时间较短，客户端关闭或者session超时都会失效
>>4.存储大小不同：
>>单个cookie保存的数据不能超过4kb，session可存储数据远高于cookie，但是当访问量过多，会占用过多的服务器资源

>问：简单描述一下token，以及其认证流程时怎么样的？

>答：token其实分为两种，一种是access token，另一种时refresh token。
>>token:
>>是访问资源接口（api）时所需的资源凭证。由uid、time、sign、组成，其特点是服务端无状态化、支持移动端设备、安全、支持跨程序调用。
>>认证流程：
>>1.客户端使用用户名密码请求登录
>>2.服务端收到请求验证用户名密码
>>3.验证通过后签发一个token并把这个token发送给客户端
>>4.客户端收到后会把他存储起来，比如放到cookie或local storage中
>>其他知识点：
>>1.每次请求都要携带token，需要把token放到http的header中
>>2.基于token的用户认证是一种服务端无状态的认证方式，服务端无需存储token数据。用解析token的计算时间换取session数据的存储空间（记住token和session区别中有一个好记忆的点就是token是用时间换空间），从而减轻服务器的压力，减少频繁的查询数据库
>>3.token完全由应用管理，所以他可以避开同源策略（协议，域名，端口都相同,就是同源, 否则就是跨域）
>
>>refresh token：专用于刷新accesaccess token的token。因为access token有效期比较短，当由于过期而失效时，使用refresh token就可以获取到新的token，从而保持长时间的登录状态

>问：token和session的区别有哪些？

>答：token无状态化：
>>session是一种记录服务器和客户端会话状态的机制，使服务端有状态化，可以记录会话信息。而token是令牌，是访问服务端资源所需的资源凭证。使服务端无状态化，不存储会话信息
>
>token更安全：
>>session和token并不冲突，作为身份认证token安全性比session好，因为每一个请求都有签名还能防止监听以及重放攻击。而session就必须依赖链路层来保障通讯安全
>
>第三方共享：
>>如果你的用户数据需要和第三方功效，或者允许第三方调用api接口，使用token

**JWT**
>概述：
>全称JSON Web Token（简称 JWT）是目前最流行的跨域认证解决方案，是一种认证授权机制
>认证流程：
>>1.用户登录成功后返回客户端一个jwt
>>2.客户端将jwt保存在本地（cookie、local storage）
>>3.请求访问受保护的路由活着资源的时候，在请求头的authorization中使用bearer模式添加jwt
>其他：
>>1.服务端的保护路由将会检查请求头 Authorization 中的 JWT 信息，如果合法，则允许用户的行为
>>2.因为 JWT 是自包含的（内部包含了一些会话信息），因此减少了需要查询数据库的需要
>>3.因为 JWT 并不使用 Cookie 的，所以你可以使用任何域名提供你的 API 服务而不需要担心跨域资源共享问题（CORS）
>>4.因为用户的状态不再存储在服务端的内存中，所以这是一种无状态的认证机制

>问：jwt和token的区别是什么？

>答：token-服务端验证客户端发送过来的token时还需要查询数据库获取用户信息，然后验证token是否有效，jwt-将token和payload加密后存储于客户端，服务端只需要使用密钥破解进行校验即可，不需要查询活着减少查询数据库，因为jwt中包含了用户信息和加密的数据

>问：什么是跨域，有哪些解决方案吗？

>答：跨域就是因为浏览器的同源策略导致它不能执行其他网站的脚本，是浏览器对js搞的安全策略
>解决方案：jsonp、cors、nginx做反向代理、node代理

>问：什么是cdn，作用是什么？

>答：cdn就是内容分发网络，是通过现有的intent中增加一层新的网络架构，将网站内容发布到最接近用户的网络边缘，是用户可就近访问所需内容，提高访问速度

**websocket**
>概述：
>>1.一种网络传输协议，位与 OSI 模型的应用层。可在单个 TCP 连接上进行全双工通信，能更好的节省服务器资源和带宽并达到实时通讯
>>2.客户端和服务器只需要完成一次握手，两者之间就可以创建持久性的连接，并进行双向数据传输
>>3.websocket 服务器与客户端通过握手连接，连接成功后，两者都能主动的向对方发送或接收数据
>
>特点：
>>1.全双工（通信允许数据在两个方向上同时传输，它在能力上相当于两个单工通信方式的结合。例如指 A→B 的同时 B→A ，是瞬时同步的）
>>2.二进制帧（采用了二进制帧结构，语法、语义与 HTTP 完全不兼容，相比http/2，WebSocket 更侧重于“实时通信”，而HTTP/2 更侧重于提高传输效率，所以两者的帧结构也有很大的区别。不像 HTTP/2 那样定义流，也就不存在多路复用、优先级等特性，自身就是全双工，也不需要服务器推送
>>3.协议名（引入ws和wss分别代表明文和密文的websocket协议，且默认端口使用80或443，几乎与http一致）
>>4.握手（WebSocket 也要有一个握手过程，然后才能正式收发数据）
>
>优点：
>>1.较小的控制开销
>>2.更强的实时性
>>3.保持创建连接
>>4.更好的二进制支持
>>5.支持拓展
>>6.更好的压缩效果
>
>应用场景：
>>1.弹幕
>>2.媒体聊天
>>3.协同编辑
>>4.基于位置的应用
>>5.体育实况更新
>>6.股票基金报价实时更新
****
### app测试
**app分类**
>1.native app：
>原生程序，一般运行在机器操作系统上，有很强的交互，一般静态资源都是在本地的。浏览使用方便，体验度高
>2.hybrid app：半原生程序，伪造了一个浏览器的apk/ipa原生程序，把地址写死了，然后里面运行了一个web app。里面是WebView UI 。但是还是运行在机器的操作系统上，交互较弱，资源一般在本地或者网络都可以。浏览体验度次之
>3.react native app：Facebook发起的开源的一套新的APP开发方案,使用JS+部分原生语法来实现功能。初次学习成本较高,但是在入门后,经过良好的封装也能够实现大部分的跨平台。而且体验很好
>4.web app：生存在浏览器里的应用，所以只能运行在浏览器里，宿主是浏览器，不再是操作系统。资源一般都在网络上。说的根本点就是一个触屏版的网站

**不同分类app优缺点**
>native:
>>优点：
>>1.体验好、优质的界面和交互
>>2.针对不同平台提供不同体验
>>3.可访问本地资源
>>4.直接访问系统api
>>5.操作响应快
>>6.用户留存高
>>缺点：
>>1.成本高（多版本、多平台）
>>2.发布新版本需要审核
>>3.盈利与三方分红
>>4.更新体验差
>
>hybrid:
>>优点：
>>1.开发成本低，可以跨平台，调试方便
>>2.维护成本低，功能可复用
>>3.可以通过原生提供api,进行资源主动下载,达到只更新资源文件,不更新apk(ipa)的效果
>>4.功能更加完善,性能和体验要比起web app好
>>缺点：
>>1.相比原生性能损耗大
>>2.这种模式受限于webview的性能桎梏,相比原生而言有不少损耗,体验无法和原生相比。不适用于交互性较强的app
>
>react native:
>>优点：
>>1.性能体验高于Hybrid,不逊色与原生
>>2.虽然说开发成本大于Hybrid模式,但是小于原生模式,大部分代码可复用
>>缺点：
>>1.虽然可以部分跨平台,但并不是Hybrid中的一次编写,两次运行那种,而是不同平台代码有所区别
>>2.这种模式实际上还是JS来写原生,所以Android和iOS中的原生代码会有所区别,如果需要跨平台,对开发人员有一定要求
>>3.开发人员学习有一定成本
>
>web:
>>优点：
>>1.开发成本低，更新快，无需用户手动升级
>>2.跨平台和终端，维护简单
>>缺点：
>>1.临时的入口，用户留存率低
>>2.无法获取系统级别的通知、提醒等功能
>>3.需要依赖网络，体验较差

>问：Android四大组件分别是那几个？

>答：1⃣️activity 2⃣️service 3⃣️broadcastrecevier 4⃣️contentprovider

**测试内容**
>1.功能测试：业务逻辑正确性测试（产品文档/测试用例）
>2.专项测试：
>>2.1 用户体验测试
>>2.2 网络测试
>>2.3 兼容测试
>>2.4 权限测试
>>2.5 安装/卸载/升级测试
>>2.6 性能测试（电量/流量/cpu/内存/启动时间）
>>2.7 稳定性测试（monkey）
>>2.8 安全性测试（密码加密/密码复制粘贴/sql注入）
>
>3.兼容性测试
>>3.1 系统兼容（Android/ios/Windows/macOS）
>>3.2 厂商兼容（miui/coloros/flyme）
>>3.3 分辨率兼容
>>3.4 网络兼容
>
>4.monkey测试
>>4.1 健壮性
>>4.2 稳定性
>>4.3 容错性
****

### linux相关
****
### 接口测试
**接口**
>概述：通常指的是前段和服务端的服务通讯接口，代码中的接口，如封装好的类
>协议：网络通信协议、http和https协议、websocket协议
>请求方式：get/post/delete/put/head/options
>mock测试：
>>概述：在测试过程中，对于某些不容易构造或者不容易获取的对象，可以用一个虚拟的对象来代替的测试方法
>>作用：
>>1.可以用来解除测试对象对外部服务的依赖，使得测试用例可以独立运行 
>>2.替换外部服务调用或一些速度较慢的操作，提升测试用例的运行速度
>>3.模拟异常逻辑，异常逻辑往往很难触发，通过Mock可以人为的控制触发异常逻辑
>>4.团队可以并行工作

**http协议**
>概述：
>>http：客户端和服务器端请求和应答的标准（TCP），用户从 www 服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少
>>https：HTTP 的安全版，即 HTTP 下加入 SSL 层，HTTPS 的安全基础是 SSL，因此加密的详细内容就需要 SSL

>问：http和https区别

>答：
>>1.https 协议需要到 ca 申请正数，一般免费证书较少，因此需要一定费用
>>2.http 是超文本传输协议，信息是明文传输，https 则是具有安全性的 ssl 加密传输协议
>>3.http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443
>>4.http 的连接很简单，是无状态的；https 协议是由 ssl+http 协议构建的可进行的加密传输、身份认证的网络协议，比 http 协议安全

>问：get和post请求方式有什么区别？

>答：
>>1.GET 提交的数据会放在 URL 之后，以?分割 URL 和传输数据，参数之间以&相连，如EditPosts.aspx?name=test1&id=123456. POST 方法是把提交的数据放在 HTTP 包的 Body 中
>>2.GET 提交的数据大小有限制（因为浏览器对 URL 的长度有限制），而 POST 方法提交的数据没有限制
>>3.GET 方式需要使用 Request.QueryString 来取得变量的值，而 POST 方式通过 Request.Form 来获取变量的值
>>4. GET 方式提交数据，会带来安全问题，比如一个登录页面，通过 GET 方式提交数据时，用户名和密码将出现在 URL 上，如果页面可以被缓存或者其他人可以访问这台机器，就可以从历史记录获得该用户的账号和密码
****
### 自动化测试
****
### python基础
****
### 网络相关
****
### 性能测试
****
### 系统架构
****
### 简单算法题
****
